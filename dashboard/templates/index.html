{% extends "base.html" %}

{% block title %}Norrtek IoT - Dashboard{% endblock %}

{% block extra_head %}
<script type="module" src="https://unpkg.com/esp-web-tools@10.1.0/dist/web/install-button.js?module"></script>
{% endblock %}

{% block content %}
<div class="container">
    <div class="header-bar">
        <div class="header-content">
            <h1><img src="{{ url_for('static', filename='norrtek-logo.png') }}" alt="Norrtek" class="brand-logo"> Norrtek IoT</h1>
            <p class="subtitle">Device Fleet Management</p>
        </div>
        <a href="/logout" class="logout-btn">Logout</a>
    </div>

    <div class="card">
        <h2>üì° Live Devices</h2>
        <div id="stats-container"></div>
        <div id="devices-container">
            <div class="empty-state">
                <p>Loading device data...</p>
            </div>
        </div>
    </div>

    <div class="card events-feed-container">
        <div class="events-feed-header">
            <div class="flex-align-center">
                <h2>üìã Events</h2>
            </div>
            <a href="/history?tab=events" class="action-link">Events History ‚Üí</a>
        </div>
        <div id="events-feed-container">
            <div class="empty-state">
                <p>Loading events...</p>
            </div>
        </div>
    </div>

    <div class="card">
        <h2>üì¶ Firmware Versions</h2>
        <table class="firmware-table" id="firmware-table">
            <thead>
                <tr>
                    <th>Product</th>
                    <th>Board</th>
                    <th>Version</th>
                    <th class="flash-column">Flash to Device</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="firmware-body">
                <tr>
                    <td colspan="5" class="muted-text text-center">Loading...</td>
                </tr>
            </tbody>
        </table>
    </div>
    
    <div id="version-modal" class="modal hidden">
        <div class="modal-content modal-lg">
            <div class="modal-header">
                <h3 id="version-modal-title">Version History</h3>
                <button class="modal-close" onclick="closeVersionModal()">&times;</button>
            </div>
            <div class="modal-body" id="version-modal-body">
                <div class="empty-state">Loading versions...</div>
            </div>
        </div>
    </div>
    
    <div id="push-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="push-modal-title">Push Version to Device</h3>
                <button class="modal-close" onclick="closePushModal()">&times;</button>
            </div>
            <div class="modal-body" id="push-modal-body">
                <p>Select a device to push this version to:</p>
                <div id="push-device-list" class="device-select-list">
                    <div class="empty-state">Loading devices...</div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="flash-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="flash-modal-title">USB Flash</h3>
                <button class="modal-close" onclick="closeFlashModal()">&times;</button>
            </div>
            <div class="modal-body" id="flash-modal-body">
                <p>Connect your device via USB and click a button below to flash:</p>
                <div class="flash-options">
                    <div class="flash-option">
                        <esp-web-install-button id="flash-modal-installer-quick" manifest="">
                            <button slot="activate" class="btn-primary flash-option-btn">
                                <span class="flash-btn-icon">‚ö°</span>
                                <span>Quick Flash</span>
                                <span class="flash-option-desc">App only - faster, keeps settings</span>
                            </button>
                        </esp-web-install-button>
                    </div>
                    <div class="flash-option" id="flash-modal-full-option">
                        <esp-web-install-button id="flash-modal-installer-full" manifest="">
                            <button slot="activate" class="btn-secondary flash-option-btn">
                                <span class="flash-btn-icon">üîß</span>
                                <span>Full Flash (Recovery)</span>
                                <span class="flash-option-desc">Complete erase - use for recovery</span>
                            </button>
                        </esp-web-install-button>
                    </div>
                </div>
                <p class="flash-version-info" id="flash-version-info"></p>
            </div>
        </div>
    </div>

    <div class="card">
        <div class="flex-between mb-15">
            <h2>üìä OTA Update Statistics</h2>
            <a href="/history?tab=updates" class="action-link">Update History ‚Üí</a>
        </div>
        <div id="ota-stats-container">
            <div class="empty-state">
                <p>Loading OTA statistics...</p>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // HTML escape function to prevent XSS attacks
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Check if IP address is IPv4 (for clickable links)
    function isIPv4(ip) {
        // Simple check: IPv4 has dots, IPv6 has colons
        return ip && !ip.includes(':');
    }

    async function loadOTAStats() {
        try {
            const response = await fetch('/api/ota-stats');
            const data = await response.json();
            
            const container = document.getElementById('ota-stats-container');
            container.innerHTML = `
                <div class="ota-stats-grid">
                    <div class="ota-stat-card">
                        <div class="label">Total Updates</div>
                        <div class="value">${data.total_updates}</div>
                    </div>
                    <div class="ota-stat-card success">
                        <div class="label">Successful</div>
                        <div class="value">${data.success_count}</div>
                    </div>
                    <div class="ota-stat-card failed">
                        <div class="label">Failed</div>
                        <div class="value">${data.failed_count}</div>
                    </div>
                    <div class="ota-stat-card in-progress">
                        <div class="label">In Progress</div>
                        <div class="value">${data.in_progress_count}</div>
                    </div>
                    <div class="ota-stat-card">
                        <div class="label">Success Rate</div>
                        <div class="value">${data.success_rate}%</div>
                    </div>
                    <div class="ota-stat-card">
                        <div class="label">Avg Duration</div>
                        <div class="value">${data.avg_duration_seconds}s</div>
                    </div>
                </div>
            `;
        } catch (error) {
            console.error('Failed to load OTA stats:', error);
            const container = document.getElementById('ota-stats-container');
            container.innerHTML = `
                <div class="empty-state">
                    <p>No OTA update data available yet</p>
                </div>
            `;
        }
    }

    // Dynamic refresh interval management
    let deviceRefreshInterval = null;
    let currentRefreshRate = 10000; // Default: 10 seconds
    
    // All refresh intervals (for pausing during USB flash)
    let timestampInterval = null;
    let otaStatsInterval = null;
    let firmwareInterval = null;
    let eventsInterval = null;
    let flashingInProgress = false;
    
    // USB flash logging state
    let currentFlashSession = null;
    let currentFlashInfo = null;
    
    function pauseAllRefresh() {
        if (flashingInProgress) return;
        flashingInProgress = true;
        console.log('Pausing all refresh intervals for USB flashing...');
        
        if (deviceRefreshInterval) clearInterval(deviceRefreshInterval);
        if (timestampInterval) clearInterval(timestampInterval);
        if (otaStatsInterval) clearInterval(otaStatsInterval);
        if (firmwareInterval) clearInterval(firmwareInterval);
        if (eventsInterval) clearInterval(eventsInterval);
        
        deviceRefreshInterval = null;
        timestampInterval = null;
        otaStatsInterval = null;
        firmwareInterval = null;
        eventsInterval = null;
    }
    
    function resumeAllRefresh() {
        if (!flashingInProgress) return;
        flashingInProgress = false;
        console.log('Resuming all refresh intervals...');
        
        timestampInterval = setInterval(updateLiveTimestamps, 1000);
        otaStatsInterval = setInterval(loadOTAStats, 30000);
        deviceRefreshInterval = setInterval(loadDevices, currentRefreshRate);
        firmwareInterval = setInterval(loadFirmware, 60000);
        eventsInterval = setInterval(loadEventsFeed, 10000);
        
        // Immediate refresh to catch up
        loadDevices();
        loadFirmware();
        loadEventsFeed();
    }
    
    // USB Flash logging API functions
    async function startFlashLog() {
        if (!currentFlashInfo) return;
        
        try {
            const response = await fetch('/api/usb-flash-log', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'start',
                    platform: currentFlashInfo.platform,
                    product: currentFlashInfo.product,
                    version: currentFlashInfo.version,
                    flash_mode: currentFlashInfo.flashMode
                })
            });
            const data = await response.json();
            if (data.success) {
                currentFlashSession = data.session_id;
                console.log('%c[USB Flash Log]', 'color: #4CAF50', 'Session started:', currentFlashSession);
            }
        } catch (error) {
            console.error('%c[USB Flash Log]', 'color: #F44336', 'Failed to start log:', error);
        }
    }
    
    async function updateFlashProgress(progress, state) {
        if (!currentFlashSession) return;
        
        try {
            await fetch('/api/usb-flash-log', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'progress',
                    session_id: currentFlashSession,
                    progress: progress,
                    state: state
                })
            });
        } catch (error) {
            console.error('%c[USB Flash Log]', 'color: #F44336', 'Failed to update progress:', error);
        }
    }
    
    async function completeFlashLog(success, errorMessage) {
        if (!currentFlashSession) return;
        
        try {
            await fetch('/api/usb-flash-log', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'complete',
                    session_id: currentFlashSession,
                    success: success,
                    error_message: errorMessage
                })
            });
            console.log('%c[USB Flash Log]', 'color: #4CAF50', 'Session completed:', success ? 'success' : 'failed');
        } catch (error) {
            console.error('%c[USB Flash Log]', 'color: #F44336', 'Failed to complete log:', error);
        } finally {
            currentFlashSession = null;
        }
    }
    
    // Extract flash info from an inline esp-web-install-button element
    function extractFlashInfoFromButton(button) {
        const manifest = button.getAttribute('manifest') || '';
        const params = new URLSearchParams(manifest.split('?')[1] || '');
        
        // Extract platform from manifest path: /firmware/manifest/{platform}.json
        const pathMatch = manifest.match(/\/manifest\/([^.]+)\.json/);
        const platform = pathMatch ? pathMatch[1] : 'unknown';
        
        // Get product and mode from query params
        const product = params.get('product') || 'unknown';
        const flashMode = params.get('mode') || 'quick';
        const version = params.get('version') || 'latest';
        
        return { platform, product, version, flashMode };
    }
    
    // Listen for ESP Web Tools state changes on all install buttons
    // This handles inline flash buttons that don't go through the modal
    document.addEventListener('state-changed', async function(e) {
        // Only handle events from esp-web-install-button elements
        if (!e.target || e.target.tagName !== 'ESP-WEB-INSTALL-BUTTON') return;
        
        const state = e.detail?.state;
        const detail = e.detail;
        
        // Detailed logging for debugging flash issues
        console.log('%c[ESP Flash]', 'color: #4CAF50; font-weight: bold', 'State:', state);
        if (detail) {
            console.log('%c[ESP Flash]', 'color: #4CAF50', 'Full detail:', JSON.stringify(detail, null, 2));
            if (detail.message) console.log('%c[ESP Flash]', 'color: #2196F3', 'Message:', detail.message);
            if (detail.manifest) console.log('%c[ESP Flash]', 'color: #FF9800', 'Manifest:', detail.manifest);
            if (detail.build) console.log('%c[ESP Flash]', 'color: #9C27B0', 'Build:', detail.build);
            if (detail.chipFamily) console.log('%c[ESP Flash]', 'color: #E91E63', 'Chip:', detail.chipFamily);
            if (detail.details) console.log('%c[ESP Flash]', 'color: #F44336', 'Details:', detail.details);
        }
        
        // Handle state transitions for logging and refresh management
        if (state === 'initializing') {
            pauseAllRefresh();
            
            // If no currentFlashInfo set (inline button), extract from button
            if (!currentFlashInfo) {
                currentFlashInfo = extractFlashInfoFromButton(e.target);
                console.log('%c[USB Flash Log]', 'color: #FF9800', 'Extracted flash info from inline button:', currentFlashInfo);
            }
            
            // Start flash log when initializing
            await startFlashLog();
        } else if (state === 'preparing') {
            await updateFlashProgress(10, 'preparing');
        } else if (state === 'erasing') {
            await updateFlashProgress(20, 'erasing');
        } else if (state === 'writing') {
            await updateFlashProgress(50, 'writing');
        } else if (state === 'finished') {
            await updateFlashProgress(100, 'finished');
            await completeFlashLog(true, null);
            // Clear flash info after completion
            currentFlashInfo = null;
            // Small delay before resuming to let the browser settle
            setTimeout(resumeAllRefresh, 1000);
        } else if (state === 'error') {
            const errorMsg = detail?.message || detail?.details || 'Unknown error';
            console.error('%c[ESP Flash ERROR]', 'color: #F44336; font-weight: bold', detail);
            await completeFlashLog(false, errorMsg);
            // Clear flash info after error
            currentFlashInfo = null;
            // Small delay before resuming to let the browser settle
            setTimeout(resumeAllRefresh, 1000);
        }
    });
    
    // Add logger to all ESP Web Tools buttons for verbose output
    const setupEspWebToolsLogging = () => {
        document.querySelectorAll('esp-web-install-button').forEach(btn => {
            if (!btn._loggerAttached) {
                btn.logger = {
                    log: (...args) => console.log('%c[esptool]', 'color: #607D8B', ...args),
                    debug: (...args) => console.debug('%c[esptool:debug]', 'color: #9E9E9E', ...args),
                    error: (...args) => console.error('%c[esptool:error]', 'color: #F44336', ...args),
                };
                btn._loggerAttached = true;
            }
        });
    };
    
    // Setup logging on page load and after DOM updates
    setupEspWebToolsLogging();
    const observer = new MutationObserver(() => setupEspWebToolsLogging());
    observer.observe(document.body, { childList: true, subtree: true });
    
    async function loadDevices() {
        try {
            const [devicesResponse, progressResponse] = await Promise.all([
                fetch('/api/devices'),
                fetch('/api/ota-progress')
            ]);
            
            const data = await devicesResponse.json();
            const otaProgress = await progressResponse.json();
            
            // Check if any OTA updates are in progress
            const hasActiveOTA = Object.keys(otaProgress).length > 0;
            
            const container = document.getElementById('devices-container');
            const statsContainer = document.getElementById('stats-container');
            
            if (data.count === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <p>${data.mqtt_enabled ? 'No devices connected yet' : 'MQTT monitoring not configured'}</p>
                        <p class="muted-text small-text-margin">
                            ${data.mqtt_enabled ? 'Devices will appear here when they send heartbeats' : 'Configure MQTT credentials to enable device monitoring'}
                        </p>
                    </div>
                `;
                statsContainer.innerHTML = '';
                return;
            }

            // Calculate degraded count
            const degradedCount = data.devices.filter(d => d.status === 'degraded').length;
            
            // Stats bar
            statsContainer.innerHTML = `
                <div class="stats-bar">
                    <div>Total: <span>${data.count}</span></div>
                    <div>üü¢ Online: <span>${data.online_count - degradedCount}</span></div>
                    ${degradedCount > 0 ? `<div>üü† Degraded: <span>${degradedCount}</span></div>` : ''}
                    <div>üî¥ Offline: <span>${data.offline_count}</span></div>
                </div>
            `;

            const devicesHtml = data.devices.map(device => {
                // Escape all user-supplied data to prevent XSS
                const safeDeviceId = escapeHtml(device.device_id);
                const safeProduct = escapeHtml(device.product || 'Unknown Product');
                const safeBoard = escapeHtml(device.board);
                const safeVersion = escapeHtml(device.version);
                const safeSsid = escapeHtml(device.ssid);
                const safeIpAddress = escapeHtml(device.ip_address);
                
                // Check if this device has an OTA update in progress
                const ota = otaProgress[device.device_id];
                const otaHtml = ota ? `
                    <div class="ota-progress">
                        <div class="ota-progress-label">
                            üîÑ Updating: ${escapeHtml(ota.old_version || 'Unknown')} ‚Üí ${escapeHtml(ota.new_version)}
                        </div>
                        <div class="ota-progress-bar">
                            <div class="ota-progress-fill" data-progress="${ota.progress}"></div>
                            <div class="ota-progress-text">${ota.progress}%</div>
                        </div>
                    </div>
                ` : '';
                
                // Determine CSS class based on status
                const statusClass = device.status === 'offline' ? 'offline' : device.status === 'degraded' ? 'degraded' : '';
                const statusText = device.status.charAt(0).toUpperCase() + device.status.slice(1);
                
                return `
                <div class="device-card-flip-container" data-device-id="${safeDeviceId}">
                    <div class="device-card-flipper">
                        <div class="device-card-front">
                            <div class="device-card ${statusClass}">
                                <div class="device-header">
                                    <div class="device-header-left">
                                        <span class="status ${statusClass}"></span>
                                        <div class="device-header-text">
                                            <span class="device-product-name">${safeProduct}</span>
                                            <div class="device-subheading">${safeDeviceId}</div>
                                        </div>
                                    </div>
                                    <div class="flex-align-center">
                                        <span class="badge">${safeBoard}</span>
                                        <button class="flip-icon-btn" data-device-id="${safeDeviceId}" data-action="flip" title="View display snapshot">
                                            üîÑ
                                        </button>
                                    </div>
                                </div>
                                <div class="device-info">
                                    <div><strong>Status:</strong> ${statusText}${device.status === 'degraded' ? ' (unstable connection)' : ''}</div>
                                    <div><strong>Version:</strong> ${safeVersion}${device.pinned_firmware_version ? ` <span class="badge badge-warning" title="Version pinned - device will not auto-update">üìå Pinned</span>` : ''}</div>
                                    <div><strong>Uptime:</strong> ${formatUptime(device.uptime)}</div>
                                    ${device.ssid ? `<div><strong>WiFi Network:</strong> ${safeSsid}</div>` : ''}
                                    ${device.ip_address ? `<div><strong>IP Address:</strong> ${device.online && isIPv4(device.ip_address) ? `<a href="http://${encodeURIComponent(device.ip_address)}/" target="_blank" rel="noopener noreferrer" class="device-ip-link" title="Open AutoConnect page (only works if you're on the same network)">${safeIpAddress}</a>` : safeIpAddress}</div>` : ''}
                                    <div><strong>WiFi Signal:</strong> ${getSignalStrengthIcon(device.rssi)}${device.rssi} dBm</div>
                                    <div><strong>Free Memory:</strong> ${(device.free_heap / 1024).toFixed(1)} KB</div>
                                    <div><strong>Last Seen:</strong> <span class="live-timestamp" data-timestamp="${escapeHtml(device.last_seen)}">${formatTimestamp(device.last_seen)}</span></div>
                                    <div><strong>First Seen:</strong> ${formatTimestamp(device.first_seen)}</div>
                                </div>
                                ${otaHtml}
                                <div class="device-actions">
                                    <a href="/history?tab=commands&device=${encodeURIComponent(safeDeviceId)}" class="device-btn command-btn">
                                        ‚öôÔ∏è Commands
                                    </a>
                                    <button class="device-btn rollback-btn" data-device-id="${safeDeviceId}" data-action="rollback" ${device.status === 'offline' ? 'disabled title="Device must be online"' : ''}>
                                        ‚èÆÔ∏è Rollback
                                    </button>
                                    <button class="device-btn restart-btn" data-device-id="${safeDeviceId}" data-action="restart" ${device.status === 'offline' ? 'disabled title="Device must be online"' : ''}>
                                        üîÑ Restart
                                    </button>
                                    ${device.pinned_firmware_version ? `
                                    <button class="device-btn unpin-btn" data-device-id="${safeDeviceId}" data-action="unpin" title="Remove version pin - device will follow latest">
                                        üìå Unpin
                                    </button>
                                    ` : ''}
                                    <button class="device-btn delete-btn" data-device-id="${safeDeviceId}" data-action="delete">
                                        üóëÔ∏è Remove
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="device-card-back ${statusClass}" id="display-back-${safeDeviceId}">
                            <div class="device-header">
                                <div class="device-header-left">
                                    <span class="status ${statusClass}"></span>
                                    <div class="device-header-text">
                                        <span class="device-product-name">${safeProduct}</span>
                                        <div class="device-subheading">${safeDeviceId}</div>
                                    </div>
                                </div>
                                <div class="flex-align-center">
                                    <span class="badge">${safeBoard}</span>
                                    <button class="flip-icon-btn" data-device-id="${safeDeviceId}" data-action="flip" title="Back to device info">
                                        üîÑ
                                    </button>
                                </div>
                            </div>
                            <div class="text-center-margin">
                                <h3 class="snapshot-heading">Display Snapshot</h3>
                            </div>
                            <div id="display-content-${safeDeviceId}">
                                ${device.display_snapshot ? 
                                    `<div id="panel-grid-${safeDeviceId}" class="panel-grid"></div>
                                     <div class="snapshot-info">
                                         <div>Last updated: ${new Date(device.display_snapshot.timestamp).toLocaleString()}</div>
                                     </div>
                                     <div class="device-actions snapshot-actions">
                                         <button class="device-btn snapshot-btn" data-device-id="${safeDeviceId}" data-action="request-snapshot" ${device.status === 'offline' ? 'disabled' : ''}>
                                             üì∏ Request New
                                         </button>
                                         <a href="/history?tab=snapshots&device=${safeDeviceId}" class="device-btn history-btn">
                                             üìú History
                                         </a>
                                     </div>` : 
                                    `<div class="no-snapshot-message">
                                        <p>No display snapshot available</p>
                                        <p class="small-muted-text">Request a snapshot to see the display</p>
                                        <button class="snapshot-btn" data-device-id="${safeDeviceId}" data-action="request-snapshot" ${device.status === 'offline' ? 'disabled' : ''}>
                                            üì∏ Request Snapshot
                                        </button>
                                    </div>`
                                }
                            </div>
                        </div>
                    </div>
                </div>
            `;
            }).join('');

            container.innerHTML = `<div class="devices-grid">${devicesHtml}</div>`;
            
            // Attach event listeners to all device action buttons
            document.querySelectorAll('.device-btn, .flip-btn, .flip-icon-btn, .snapshot-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const deviceId = btn.getAttribute('data-device-id');
                    const action = btn.getAttribute('data-action');
                    
                    if (action === 'delete') {
                        deleteDevice(deviceId);
                    } else if (action === 'rollback') {
                        rollbackDevice(deviceId);
                    } else if (action === 'restart') {
                        restartDevice(deviceId);
                    } else if (action === 'flip') {
                        flipCard(deviceId);
                    } else if (action === 'request-snapshot') {
                        requestSnapshot(deviceId);
                    } else if (action === 'unpin') {
                        unpinDeviceVersion(deviceId);
                    } else if (action === 'set-temp-offset') {
                        setDeviceTempOffset(deviceId);
                    }
                });
            });
            
            // Update all progress bar widths from data attributes
            updateProgressBars();
            
            // Render display snapshots on canvases
            data.devices.forEach(device => {
                if (device.display_snapshot) {
                    renderDisplaySnapshot(device.device_id, device.display_snapshot);
                }
            });
            
            // Restore flip states for cards that were flipped before refresh
            restoreFlipStates();
            
            // Adjust refresh interval based on OTA status
            adjustRefreshInterval(hasActiveOTA);
        } catch (error) {
            console.error('Failed to load devices:', error);
        }
    }
    
    function adjustRefreshInterval(hasActiveOTA) {
        const desiredRate = hasActiveOTA ? 1000 : 10000; // 1s during OTA, 10s otherwise
        
        // Only restart interval if rate needs to change
        if (desiredRate !== currentRefreshRate) {
            currentRefreshRate = desiredRate;
            
            if (deviceRefreshInterval) {
                clearInterval(deviceRefreshInterval);
            }
            
            deviceRefreshInterval = setInterval(loadDevices, currentRefreshRate);
            
            const rateLabel = hasActiveOTA ? '1 second' : '10 seconds';
            console.log(`üîÑ Refresh rate changed to ${rateLabel} (OTA active: ${hasActiveOTA})`);
        }
    }

    async function deleteDevice(deviceId) {
        if (!confirm(`Are you sure you want to remove device ${deviceId}?\n\nThis will permanently delete it from the database.`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/devices/${deviceId}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                alert('Device removed successfully');
                loadDevices();
            } else {
                const error = await response.json();
                alert(`Failed to remove device: ${error.error}`);
            }
        } catch (error) {
            console.error('Failed to delete device:', error);
            alert('Failed to remove device');
        }
    }

    async function rollbackDevice(deviceId) {
        if (!confirm(`Send rollback command to ${deviceId}?\n\nThis will instruct the device to restore its previous firmware version.`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/devices/${deviceId}/rollback`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            
            if (response.ok) {
                alert(data.message || 'Rollback command sent successfully');
            } else {
                alert(`Failed to send rollback command: ${data.error}`);
            }
        } catch (error) {
            console.error('Failed to send rollback command:', error);
            alert('Failed to send rollback command');
        }
    }

    async function restartDevice(deviceId) {
        if (!confirm(`Send restart command to ${deviceId}?\n\nThis will reboot the device.`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/devices/${deviceId}/restart`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            
            if (response.ok) {
                alert(data.message || 'Restart command sent successfully');
            } else {
                alert(`Failed to send restart command: ${data.error}`);
            }
        } catch (error) {
            console.error('Failed to send restart command:', error);
            alert('Failed to send restart command');
        }
    }

    async function setDeviceTempOffset(deviceId) {
        const input = document.getElementById(`temp-offset-${deviceId}`);
        if (!input) {
            alert('Temperature offset input not found');
            return;
        }
        
        const value = parseFloat(input.value);
        if (isNaN(value)) {
            alert('Please enter a valid temperature offset value');
            return;
        }
        
        if (value < -20 || value > 20) {
            alert('Temperature offset must be between -20 and 20 degrees');
            return;
        }
        
        try {
            const response = await fetch(`/api/devices/${deviceId}/config`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ temp_offset: value })
            });
            
            const data = await response.json();
            
            if (response.ok) {
                alert(data.message || 'Temperature offset sent to device');
                input.value = '';
            } else {
                alert(`Failed to set temperature offset: ${data.error}`);
            }
        } catch (error) {
            console.error('Failed to set temperature offset:', error);
            alert('Failed to set temperature offset');
        }
    }

    // Track which cards are currently flipped (persists across refreshes)
    const flippedCards = new Set();

    function flipCard(deviceId) {
        const container = document.querySelector(`[data-device-id="${deviceId}"].device-card-flip-container`);
        if (container) {
            container.classList.toggle('flipped');
            
            // Track flip state
            if (container.classList.contains('flipped')) {
                flippedCards.add(deviceId);
            } else {
                flippedCards.delete(deviceId);
            }
        }
    }

    function restoreFlipStates() {
        // Restore flipped state for all cards that were flipped before refresh
        flippedCards.forEach(deviceId => {
            const container = document.querySelector(`[data-device-id="${deviceId}"].device-card-flip-container`);
            if (container && !container.classList.contains('flipped')) {
                const flipper = container.querySelector('.device-card-flipper');
                
                // Temporarily disable transitions to prevent animation on restore
                if (flipper) {
                    flipper.classList.add('no-transition');
                }
                
                container.classList.add('flipped');
                
                // Force reflow to ensure no-transition is applied
                if (flipper) {
                    flipper.offsetHeight; // Trigger reflow
                    
                    // Re-enable transitions after a brief delay
                    setTimeout(() => {
                        flipper.classList.remove('no-transition');
                    }, 10);
                }
            }
        });
    }

    function renderDisplaySnapshot(deviceId, snapshot) {
        if (!snapshot) return;
        
        const grid = document.getElementById(`panel-grid-${deviceId}`);
        if (!grid) return;
        
        try {
            grid.innerHTML = '';
            
            // Check for new per-row format: {rows: [{cols, width, height, mono, monoColor, ...}, ...]}
            const rowsArray = snapshot.rows;
            
            if (rowsArray && Array.isArray(rowsArray) && rowsArray.length > 0) {
                // NEW PER-ROW FORMAT: Each row has independent dimensions
                const maxWidth = Math.max(...rowsArray.map(r => r.width || 0));
                const panelWidth = 16;
                const panelHeight = 16;
                
                // Calculate responsive scale factor based on container width
                const container = grid.parentElement;
                const containerWidth = container ? container.clientWidth : 300;
                const maxCols = Math.max(...rowsArray.map(r => r.cols || 1));
                const gapPixels = (maxCols - 1) * 1;
                const paddingPixels = 2;
                const availableWidth = containerWidth - gapPixels - paddingPixels - 40;
                
                const maxScaleByWidth = Math.floor(availableWidth / (panelWidth * maxCols));
                const scale = Math.max(4, Math.min(12, maxScaleByWidth));
                
                for (let rowIndex = 0; rowIndex < rowsArray.length; rowIndex++) {
                    const rowData = rowsArray[rowIndex];
                    const rowWidth = rowData.width || 48;
                    const rowHeight = rowData.height || 16;
                    const rowCols = rowData.cols || 3;
                    
                    // Get pixel data for this row
                    const monoData = rowData.mono;
                    const colorData = rowData.color;
                    
                    if (!monoData && !colorData) continue;
                    
                    const isColorMode = !!colorData;
                    let pixelData = null;
                    let colorPixelData = null;
                    
                    if (isColorMode) {
                        colorPixelData = atob(colorData);
                    } else {
                        pixelData = atob(monoData);
                    }
                    
                    // Get mono color for this row
                    let monoR = 255, monoG = 255, monoB = 255;
                    if (rowData.monoColor && rowData.monoColor.length >= 3) {
                        monoR = rowData.monoColor[0];
                        monoG = rowData.monoColor[1];
                        monoB = rowData.monoColor[2];
                        if (rowData.monoColor.length >= 4) {
                            const rawBrightness = rowData.monoColor[3] / 255;
                            const brightness = Math.max(rawBrightness, 0.3);
                            monoR = Math.round(monoR * brightness);
                            monoG = Math.round(monoG * brightness);
                            monoB = Math.round(monoB * brightness);
                        }
                    }
                    
                    // Create a container for this row
                    const rowContainer = document.createElement('div');
                    rowContainer.className = 'panel-row';
                    rowContainer.style.display = 'flex';
                    rowContainer.style.justifyContent = 'center';
                    
                    // Render each panel in the row
                    for (let col = 0; col < rowCols; col++) {
                        const canvas = document.createElement('canvas');
                        canvas.width = panelWidth;
                        canvas.height = panelHeight;
                        canvas.style.width = `${panelWidth * scale}px`;
                        canvas.style.height = `${panelHeight * scale}px`;
                        canvas.style.imageRendering = 'pixelated';
                        canvas.style.display = 'block';
                        canvas.style.background = '#000';
                        
                        const ctx = canvas.getContext('2d');
                        const imageData = ctx.createImageData(panelWidth, panelHeight);
                        
                        for (let py = 0; py < panelHeight; py++) {
                            for (let px = 0; px < panelWidth; px++) {
                                // Calculate pixel index within this row's data
                                const globalX = col * panelWidth + px;
                                const globalY = py;
                                const globalPixelIndex = globalY * rowWidth + globalX;
                                
                                const i = (py * panelWidth + px) * 4;
                                
                                if (isColorMode) {
                                    const colorByteIndex = globalPixelIndex * 4;
                                    const r = colorPixelData.charCodeAt(colorByteIndex) || 0;
                                    const g = colorPixelData.charCodeAt(colorByteIndex + 1) || 0;
                                    const b = colorPixelData.charCodeAt(colorByteIndex + 2) || 0;
                                    const brightness = (colorPixelData.charCodeAt(colorByteIndex + 3) || 255) / 255;
                                    
                                    imageData.data[i] = Math.round(r * brightness);
                                    imageData.data[i + 1] = Math.round(g * brightness);
                                    imageData.data[i + 2] = Math.round(b * brightness);
                                    imageData.data[i + 3] = 255;
                                } else {
                                    const byteIndex = Math.floor(globalPixelIndex / 8);
                                    const bitIndex = globalPixelIndex % 8;
                                    const byte = pixelData.charCodeAt(byteIndex) || 0;
                                    const isOn = (byte & (1 << bitIndex)) !== 0;
                                    
                                    if (isOn) {
                                        imageData.data[i] = monoR;
                                        imageData.data[i + 1] = monoG;
                                        imageData.data[i + 2] = monoB;
                                        imageData.data[i + 3] = 255;
                                    } else {
                                        imageData.data[i] = 0;
                                        imageData.data[i + 1] = 0;
                                        imageData.data[i + 2] = 0;
                                        imageData.data[i + 3] = 255;
                                    }
                                }
                            }
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                        rowContainer.appendChild(canvas);
                    }
                    
                    grid.appendChild(rowContainer);
                }
            } else {
                // LEGACY FORMAT: Single mono/color field with shared dimensions
                const colorData = snapshot.color;
                const monoData = snapshot.mono || snapshot.pixels;
                
                if (!monoData && !colorData) return;
                
                const width = snapshot.width || 48;
                const height = snapshot.height || 32;
                const rows = snapshot.rows || 2;
                const cols = snapshot.cols || 3;
                
                const isColorMode = !!colorData;
                let pixelData = null;
                let colorPixelData = null;
                
                if (isColorMode) {
                    colorPixelData = atob(colorData);
                } else {
                    pixelData = atob(monoData);
                }
                
                let monoR = 255, monoG = 255, monoB = 255;
                if (snapshot.monoColor && snapshot.monoColor.length >= 3) {
                    monoR = snapshot.monoColor[0];
                    monoG = snapshot.monoColor[1];
                    monoB = snapshot.monoColor[2];
                    if (snapshot.monoColor.length >= 4) {
                        const rawBrightness = snapshot.monoColor[3] / 255;
                        const brightness = Math.max(rawBrightness, 0.3);
                        monoR = Math.round(monoR * brightness);
                        monoG = Math.round(monoG * brightness);
                        monoB = Math.round(monoB * brightness);
                    }
                }
                
                const panelWidth = width / cols;
                const panelHeight = height / rows;
                
                // Calculate responsive scale factor based on container width
                const container = grid.parentElement;
                const containerWidth = container ? container.clientWidth : 300;
                const gapPixels = (cols - 1) * 1;
                const paddingPixels = 2;
                const availableWidth = containerWidth - gapPixels - paddingPixels - 40;
                
                const maxScaleByWidth = Math.floor(availableWidth / (panelWidth * cols));
                const scale = Math.max(4, Math.min(12, maxScaleByWidth));
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const canvas = document.createElement('canvas');
                        canvas.width = panelWidth;
                        canvas.height = panelHeight;
                        canvas.style.width = `${panelWidth * scale}px`;
                        canvas.style.height = `${panelHeight * scale}px`;
                        canvas.style.imageRendering = 'pixelated';
                        canvas.style.display = 'block';
                        canvas.style.background = '#000';
                        
                        const ctx = canvas.getContext('2d');
                        const imageData = ctx.createImageData(panelWidth, panelHeight);
                        
                        for (let py = 0; py < panelHeight; py++) {
                            for (let px = 0; px < panelWidth; px++) {
                                const globalX = col * panelWidth + px;
                                const globalY = row * panelHeight + py;
                                const globalPixelIndex = globalY * width + globalX;
                                
                                const i = (py * panelWidth + px) * 4;
                                
                                if (isColorMode) {
                                    const colorByteIndex = globalPixelIndex * 4;
                                    const r = colorPixelData.charCodeAt(colorByteIndex) || 0;
                                    const g = colorPixelData.charCodeAt(colorByteIndex + 1) || 0;
                                    const b = colorPixelData.charCodeAt(colorByteIndex + 2) || 0;
                                    const brightness = (colorPixelData.charCodeAt(colorByteIndex + 3) || 255) / 255;
                                    
                                    imageData.data[i] = Math.round(r * brightness);
                                    imageData.data[i + 1] = Math.round(g * brightness);
                                    imageData.data[i + 2] = Math.round(b * brightness);
                                    imageData.data[i + 3] = 255;
                                } else {
                                    const byteIndex = Math.floor(globalPixelIndex / 8);
                                    const bitIndex = globalPixelIndex % 8;
                                    const byte = pixelData.charCodeAt(byteIndex) || 0;
                                    const isOn = (byte & (1 << bitIndex)) !== 0;
                                    
                                    if (isOn) {
                                        imageData.data[i] = monoR;
                                        imageData.data[i + 1] = monoG;
                                        imageData.data[i + 2] = monoB;
                                        imageData.data[i + 3] = 255;
                                    } else {
                                        imageData.data[i] = 0;
                                        imageData.data[i + 1] = 0;
                                        imageData.data[i + 2] = 0;
                                        imageData.data[i + 3] = 255;
                                    }
                                }
                            }
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                        grid.appendChild(canvas);
                    }
                }
            }
            
        } catch (error) {
            console.error('Failed to render display snapshot:', error);
        }
    }

    async function requestSnapshot(deviceId) {
        try {
            const response = await fetch(`/api/devices/${deviceId}/snapshot`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            
            if (response.ok) {
                alert(data.message || 'Snapshot request sent to device');
            } else {
                alert(`Failed to request snapshot: ${data.error}`);
            }
        } catch (error) {
            console.error('Failed to request snapshot:', error);
            alert('Failed to request snapshot');
        }
    }

    // Store firmware data globally for platform switching
    let firmwareData = {};

    async function loadFirmware() {
        try {
            const response = await fetch('/api/status');
            const data = await response.json();
            const tbody = document.getElementById('firmware-body');
            
            // Store for later use in platform switching
            firmwareData = data.firmwares;
            
            // Group by product - one row per product
            const rows = Object.entries(data.firmwares).map(([product, platforms]) => {
                // Get list of available platforms for this product
                const availablePlatforms = Object.entries(platforms)
                    .filter(([_, fw]) => fw !== null)
                    .map(([platform, fw]) => ({ platform, fw }));
                
                if (availablePlatforms.length === 0) return '';
                
                // Use first platform as default
                const defaultPlatform = availablePlatforms[0].platform;
                const defaultFw = availablePlatforms[0].fw;
                const rowId = `fw-row-${product}`;
                
                // Build platform dropdown
                const platformOptions = availablePlatforms.map(({ platform }) => 
                    `<option value="${platform}">${platform.toUpperCase()}</option>`
                ).join('');
                
                const platformDropdown = availablePlatforms.length > 1 
                    ? `<select class="platform-select" onchange="switchPlatform('${product}', this.value)">${platformOptions}</select>`
                    : `<span class="platform-single">${defaultPlatform.toUpperCase()}</span>`;
                
                // Check permissions for default platform
                const canDownload = defaultFw.can_download !== false;
                const downloadUrl = defaultFw.public_download_url || defaultFw.download_url || '#';
                const supportsFullFlash = defaultFw.supports_full_flash || false;
                const uniqueId = `${product}-${defaultPlatform}`;
                
                const filename = defaultFw.filename || '';
                const version = defaultFw.version || 'Unknown';
                
                if (canDownload) {
                    // Build flash button with dropdown for full flash if available
                    let flashButtons = buildFlashButtons(product, defaultPlatform, supportsFullFlash);
                    
                    return `
                        <tr id="${rowId}" data-product="${product}" data-selected-platform="${defaultPlatform}">
                            <td>${escapeHtml(product)}</td>
                            <td>${platformDropdown}</td>
                            <td>
                                <a href="${downloadUrl}" class="table-link version-link" id="version-link-${product}" title="Download ${escapeHtml(filename)}">
                                    ${escapeHtml(version)}
                                </a>
                            </td>
                            <td class="flash-column" id="flash-cell-${product}">
                                ${flashButtons}
                            </td>
                            <td>
                                <button class="btn-secondary btn-small" onclick="showVersionHistoryForRow('${product}')">
                                    üìú History
                                </button>
                            </td>
                        </tr>
                    `;
                } else {
                    return `
                        <tr id="${rowId}" data-product="${product}" data-selected-platform="${defaultPlatform}" class="opacity-50">
                            <td>${escapeHtml(product)}</td>
                            <td>${platformDropdown}</td>
                            <td id="version-link-${product}">${escapeHtml(version)}</td>
                            <td class="flash-column" id="flash-cell-${product}"><span class="muted-text">No Permission</span></td>
                            <td>
                                <button class="btn-secondary btn-small" onclick="showVersionHistoryForRow('${product}')">
                                    üìú History
                                </button>
                            </td>
                        </tr>
                    `;
                }
            }).join('');

            tbody.innerHTML = rows || '<tr><td colspan="5" class="muted-text text-center">No firmware uploaded yet</td></tr>';
        } catch (error) {
            console.error('Failed to load firmware:', error);
        }
    }

    function buildFlashButtons(product, platform, supportsFullFlash) {
        const uniqueId = `${product}-${platform}`;
        
        if (supportsFullFlash) {
            return `
                <div class="split-button-group" data-platform="${platform}" data-product="${product}">
                    <esp-web-install-button id="flash-installer-${uniqueId}" manifest="/firmware/manifest/${platform}.json?product=${encodeURIComponent(product)}&mode=quick">
                        <button slot="activate" class="flash-btn flash-btn-main" id="flash-btn-${uniqueId}">
                            <span class="flash-btn-icon">‚ö°</span>
                            <span class="flash-btn-text">Quick Flash</span>
                        </button>
                    </esp-web-install-button>
                    <button class="flash-btn flash-btn-dropdown" onclick="toggleFlashDropdown(event, '${uniqueId}')" title="Flash options">‚ñº</button>
                    <div class="flash-dropdown" id="flash-dropdown-${uniqueId}">
                        <button class="flash-dropdown-item" onclick="switchFlashMode('${uniqueId}', 'full', '${product}')" data-mode="full">
                            <span class="flash-btn-icon">üîß</span> Full Flash (Recovery)
                        </button>
                        <button class="flash-dropdown-item is-hidden" onclick="switchFlashMode('${uniqueId}', 'quick', '${product}')" data-mode="quick">
                            <span class="flash-btn-icon">‚ö°</span> Quick Flash
                        </button>
                    </div>
                </div>
            `;
        } else {
            return `
                <div class="split-button-group">
                    <esp-web-install-button manifest="/firmware/manifest/${platform}.json?product=${encodeURIComponent(product)}&mode=quick">
                        <button slot="activate" class="flash-btn flash-btn-main flash-btn-single">
                            <span class="flash-btn-icon">‚ö°</span>
                            <span class="flash-btn-text">Quick Flash</span>
                        </button>
                    </esp-web-install-button>
                </div>
            `;
        }
    }

    function switchPlatform(product, newPlatform) {
        const fw = firmwareData[product]?.[newPlatform];
        const row = document.getElementById(`fw-row-${product}`);
        
        // Handle missing firmware for this platform
        if (!fw) {
            const versionCell = document.getElementById(`version-link-${product}`);
            if (versionCell) {
                versionCell.outerHTML = `<span id="version-link-${product}" class="muted-text">No firmware</span>`;
            }
            const flashCell = document.getElementById(`flash-cell-${product}`);
            if (flashCell) {
                flashCell.innerHTML = '<span class="muted-text">-</span>';
            }
            if (row) {
                row.classList.add('opacity-50');
                row.dataset.selectedPlatform = newPlatform;
            }
            return;
        }
        
        const canDownload = fw.can_download !== false;
        const downloadUrl = fw.public_download_url || fw.download_url || '#';
        const supportsFullFlash = fw.supports_full_flash || false;
        const filename = fw.filename || '';
        const version = fw.version || 'Unknown';
        
        // Update version link
        const versionCell = document.getElementById(`version-link-${product}`);
        if (versionCell) {
            if (canDownload) {
                versionCell.outerHTML = `<a href="${downloadUrl}" class="table-link version-link" id="version-link-${product}" title="Download ${escapeHtml(filename)}">${escapeHtml(version)}</a>`;
            } else {
                versionCell.outerHTML = `<span id="version-link-${product}">${escapeHtml(version)}</span>`;
            }
        }
        
        // Update flash buttons
        const flashCell = document.getElementById(`flash-cell-${product}`);
        if (flashCell) {
            if (canDownload) {
                flashCell.innerHTML = buildFlashButtons(product, newPlatform, supportsFullFlash);
            } else {
                flashCell.innerHTML = '<span class="muted-text">No Permission</span>';
            }
        }
        
        // Update row opacity based on permission
        if (row) {
            row.classList.toggle('opacity-50', !canDownload);
            row.dataset.selectedPlatform = newPlatform;
        }
    }

    function showVersionHistoryForRow(product) {
        const row = document.getElementById(`fw-row-${product}`);
        const platform = row?.dataset.selectedPlatform || row?.querySelector('.platform-select')?.value || row?.querySelector('.platform-single')?.textContent?.toLowerCase();
        if (platform) {
            showVersionHistory(platform.toLowerCase(), product);
        }
    }

    function updateProgressBars() {
        document.querySelectorAll('[data-progress]').forEach(element => {
            const progress = element.getAttribute('data-progress');
            element.style.width = `${progress}%`;
        });
    }

    function formatUptime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        return `${hours}h ${minutes}m`;
    }

    function getSignalStrengthIcon(rssi) {
        // RSSI to signal strength conversion:
        // Excellent: > -50 dBm (4 bars)
        // Good: -50 to -60 dBm (3 bars)
        // Fair: -60 to -70 dBm (2 bars)
        // Poor: < -70 dBm (1 bar)
        let bars = 1;
        if (rssi > -50) bars = 4;
        else if (rssi > -60) bars = 3;
        else if (rssi > -70) bars = 2;
        
        return `
            <span class="signal-icon">
                <span class="bar ${bars >= 1 ? 'active' : ''}"></span>
                <span class="bar ${bars >= 2 ? 'active' : ''}"></span>
                <span class="bar ${bars >= 3 ? 'active' : ''}"></span>
                <span class="bar ${bars >= 4 ? 'active' : ''}"></span>
            </span>
        `;
    }

    function formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diffSeconds = Math.floor((now - date) / 1000);
        
        if (diffSeconds < 60) return `${diffSeconds}s ago`;
        if (diffSeconds < 3600) return `${Math.floor(diffSeconds / 60)}m ago`;
        if (diffSeconds < 86400) return `${Math.floor(diffSeconds / 3600)}h ago`;
        
        const isToday = date.toDateString() === now.toDateString();
        const yesterday = new Date(now);
        yesterday.setDate(yesterday.getDate() - 1);
        const isYesterday = date.toDateString() === yesterday.toDateString();
        
        if (isToday) {
            return `Today ${date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`;
        } else if (isYesterday) {
            return `Yesterday ${date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`;
        } else {
            return date.toLocaleDateString([], {month: 'short', day: 'numeric'}) + ' ' + 
                   date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
        }
    }

    function updateLiveTimestamps() {
        // Update all live timestamp elements
        const timestamps = document.querySelectorAll('.live-timestamp');
        timestamps.forEach(elem => {
            const timestamp = elem.getAttribute('data-timestamp');
            if (timestamp) {
                elem.textContent = formatTimestamp(timestamp);
            }
        });
    }

    function toggleFlashDropdown(event, platform) {
        event.stopPropagation();
        const dropdown = document.getElementById(`flash-dropdown-${platform}`);
        const allDropdowns = document.querySelectorAll('.flash-dropdown');
        
        // Close all other dropdowns
        allDropdowns.forEach(d => {
            if (d !== dropdown) {
                d.classList.remove('show');
            }
        });
        
        // Toggle this dropdown
        dropdown.classList.toggle('show');
    }

    function switchFlashMode(uniqueId, newMode, product) {
        // uniqueId is "${product}-${platform}"
        const installer = document.getElementById(`flash-installer-${uniqueId}`);
        const button = document.getElementById(`flash-btn-${uniqueId}`);
        const dropdown = document.getElementById(`flash-dropdown-${uniqueId}`);
        const group = button.closest('.split-button-group');
        const dropdownBtn = group.querySelector('.flash-btn-dropdown');
        const platform = group.dataset.platform;
        
        // Update manifest URL with product parameter
        installer.setAttribute('manifest', `/firmware/manifest/${platform}.json?product=${encodeURIComponent(product)}&mode=${newMode}`);
        
        // Update button text and icon based on mode
        const iconSpan = button.querySelector('.flash-btn-icon');
        const textSpan = button.querySelector('.flash-btn-text');
        
        if (newMode === 'full') {
            iconSpan.textContent = 'üîß';
            textSpan.textContent = 'Full Flash';
            button.classList.add('full-flash-mode');
            dropdownBtn.classList.add('full-flash-mode');
        } else {
            iconSpan.textContent = '‚ö°';
            textSpan.textContent = 'Quick Flash';
            button.classList.remove('full-flash-mode');
            dropdownBtn.classList.remove('full-flash-mode');
        }
        
        // Toggle dropdown items visibility (show opposite mode)
        const dropdownItems = dropdown.querySelectorAll('.flash-dropdown-item');
        dropdownItems.forEach(item => {
            const itemMode = item.getAttribute('data-mode');
            if (itemMode === newMode) {
                item.classList.add('is-hidden');
            } else {
                item.classList.remove('is-hidden');
            }
        });
        
        // Close the dropdown
        dropdown.classList.remove('show');
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (event) => {
        if (!event.target.closest('.split-button-group')) {
            document.querySelectorAll('.flash-dropdown').forEach(d => {
                d.classList.remove('show');
            });
        }
    });

    // Handle tab visibility changes to recalculate after backgrounding
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
            // Tab is now visible - recalculate all timestamps immediately
            updateLiveTimestamps();
        }
    });

    // Check for Web Serial API support and hide flash column if not available
    function checkWebSerialSupport() {
        if (!('serial' in navigator)) {
            // Add persistent class to body that hides flash column via CSS
            document.body.classList.add('no-web-serial');
            console.log('Web Serial API not supported - Flash to Device column hidden');
        }
    }

    async function loadEventsFeed() {
        try {
            const response = await fetch('/api/events?limit=10');
            const data = await response.json();
            
            const container = document.getElementById('events-feed-container');
            
            if (!data.events || data.events.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <p>No events yet</p>
                    </div>
                `;
                return;
            }
            
            const tableHtml = `
                <div class="table-responsive">
                    <table class="events-feed-table">
                        <thead>
                            <tr>
                                <th>Time</th>
                                <th>Device</th>
                                <th>Event</th>
                                <th>Details</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.events.map(event => {
                                const eventIcon = getEventIcon(event.event_type);
                                const eventDetails = formatEventData(event.event_type, event.event_data);
                                
                                return `
                                    <tr>
                                        <td>${new Date(event.timestamp).toLocaleTimeString()}</td>
                                        <td>${escapeHtml(event.product || 'Unknown')} (${escapeHtml(event.device_id)})</td>
                                        <td><span class="event-badge ${event.event_type}">${eventIcon} ${formatEventType(event.event_type)}</span></td>
                                        <td>${eventDetails}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = tableHtml;
            
        } catch (error) {
            console.error('Failed to load events feed:', error);
        }
    }

    function getEventIcon(eventType) {
        const icons = {
            'heartbeat': 'üíì',
            'boot': 'üîå',
            'wifi_connect': 'üì∂',
            'wifi_disconnect': 'üìµ',
            'mqtt_connect': 'üîó',
            'mqtt_disconnect': 'üîì',
            'temperature_read': 'üå°Ô∏è',
            'temperature_error': '‚ö†Ô∏è',
            'temp_sensor_not_found': '‚ùå',
            'temp_read_invalid': '‚ö†Ô∏è',
            'temp_read_crc_error': '‚ö†Ô∏è',
            'button_press': 'üëÜ',
            'display_mode_change': 'üñ•Ô∏è',
            'low_heap_warning': '‚ö†Ô∏è',
            'wifi_rssi_low': 'üìâ',
            'ntp_sync_success': 'üïê',
            'ntp_sync_failed': '‚è∞',
            'rtc_initialized': '‚è±Ô∏è',
            'rtc_not_found': '‚ùå',
            'rtc_lost_power': 'üîã',
            'rtc_time_invalid': '‚è∞',
            'rtc_synced_from_ntp': 'üîÑ',
            'rtc_sync_failed': '‚ö†Ô∏è',
            'rtc_drift_corrected': 'üîß'
        };
        return icons[eventType] || 'üìå';
    }

    function formatEventType(eventType) {
        const labels = {
            'heartbeat': 'Heartbeat',
            'boot': 'Boot',
            'wifi_connect': 'WiFi Connect',
            'wifi_disconnect': 'WiFi Disconnect',
            'mqtt_connect': 'MQTT Connect',
            'mqtt_disconnect': 'MQTT Disconnect',
            'temperature_read': 'Temperature',
            'temperature_error': 'Temperature Error',
            'temp_sensor_not_found': 'Temp Sensor Missing',
            'temp_read_invalid': 'Temp Read Invalid',
            'temp_read_crc_error': 'Temp CRC Error',
            'button_press': 'Button Press',
            'display_mode_change': 'Display Mode',
            'low_heap_warning': 'Low Heap',
            'wifi_rssi_low': 'Weak WiFi',
            'ntp_sync_success': 'NTP Synced',
            'ntp_sync_failed': 'NTP Failed',
            'rtc_initialized': 'RTC Init',
            'rtc_not_found': 'RTC Missing',
            'rtc_lost_power': 'RTC Lost Power',
            'rtc_time_invalid': 'RTC Invalid',
            'rtc_synced_from_ntp': 'RTC Synced',
            'rtc_sync_failed': 'RTC Sync Failed',
            'rtc_drift_corrected': 'RTC Drift Fixed'
        };
        return labels[eventType] || eventType;
    }

    function formatEventData(eventType, eventData) {
        if (!eventData) return '-';
        
        try {
            const data = typeof eventData === 'string' ? JSON.parse(eventData) : eventData;
            
            switch (eventType) {
                case 'heartbeat':
                    const parts = [];
                    if (data.version) parts.push(`v${escapeHtml(data.version)}`);
                    if (data.rssi) parts.push(`${data.rssi} dBm`);
                    if (data.uptime) parts.push(`uptime: ${formatUptime(data.uptime)}`);
                    if (data.free_heap) parts.push(`heap: ${Math.round(data.free_heap / 1024)}KB`);
                    return parts.join(', ') || '-';
                case 'boot':
                    return data.reason ? `Reason: ${escapeHtml(data.reason)}` : '-';
                case 'wifi_connect':
                    const wifiParts = [];
                    if (data.ssid) wifiParts.push(`SSID: ${escapeHtml(data.ssid)}`);
                    if (data.rssi) wifiParts.push(`${data.rssi} dBm`);
                    if (data.ip) wifiParts.push(`IP: ${escapeHtml(data.ip)}`);
                    return wifiParts.join(', ') || '-';
                case 'wifi_disconnect':
                    return data.reason ? `Reason: ${escapeHtml(data.reason)}` : '-';
                case 'temperature_read':
                    return data.celsius !== undefined ? `${data.celsius.toFixed(1)}¬∞C` : '-';
                case 'temperature_error':
                    return data.error ? escapeHtml(data.error) : 'Sensor error';
                case 'temp_read_invalid':
                    if (data.reason) return `${escapeHtml(data.reason)}${data.raw !== undefined ? ` (${data.raw}¬∞C)` : ''}`;
                    return data.raw !== undefined ? `Raw: ${data.raw}¬∞C` : 'Invalid reading';
                case 'temp_read_crc_error':
                    return 'CRC checksum error';
                case 'temp_sensor_not_found':
                    return 'Sensor disconnected';
                case 'button_press':
                    return 'Pressed';
                case 'display_mode_change':
                    if (data.from && data.to) return `${escapeHtml(data.from)} ‚Üí ${escapeHtml(data.to)}`;
                    return data.to ? `Mode: ${escapeHtml(data.to)}` : '-';
                case 'low_heap_warning':
                    return data.free_heap !== undefined ? `${Math.round(data.free_heap / 1024)}KB free (threshold: ${Math.round(data.threshold / 1024)}KB)` : 'Low memory';
                case 'wifi_rssi_low':
                    return data.rssi !== undefined ? `${data.rssi} dBm (threshold: ${data.threshold} dBm)` : 'Weak signal';
                case 'ntp_sync_success':
                    return 'Time synchronized';
                case 'ntp_sync_failed':
                    return data.reason ? escapeHtml(data.reason) : 'Sync failed';
                case 'rtc_initialized':
                    return 'RTC found and ready';
                case 'rtc_not_found':
                    return 'RTC not detected on I2C';
                case 'rtc_lost_power':
                    return 'Battery depleted, time reset';
                case 'rtc_time_invalid':
                    return 'RTC time before 2020';
                case 'rtc_synced_from_ntp':
                    return 'RTC updated from NTP';
                case 'rtc_sync_failed':
                    return data.reason ? escapeHtml(data.reason) : 'Sync failed';
                case 'rtc_drift_corrected':
                    return data.drift_seconds !== undefined ? `Drift: ${data.drift_seconds}s` : 'Drift corrected';
                default:
                    return JSON.stringify(data);
            }
        } catch (e) {
            return String(eventData);
        }
    }

    // Version history and push functionality
    let firmwareHistoryCache = null;
    let selectedPushVersion = null;
    let selectedPushPlatform = null;
    
    async function loadFirmwareHistory() {
        if (firmwareHistoryCache) return firmwareHistoryCache;
        
        try {
            const response = await fetch('/api/firmware-history');
            const data = await response.json();
            firmwareHistoryCache = data;
            return data;
        } catch (error) {
            console.error('Failed to load firmware history:', error);
            return null;
        }
    }
    
    async function showVersionHistory(platform, product) {
        const modal = document.getElementById('version-modal');
        const title = document.getElementById('version-modal-title');
        const body = document.getElementById('version-modal-body');
        
        title.textContent = `Version History - ${escapeHtml(product)} (${platform.toUpperCase()})`;
        body.innerHTML = '<div class="empty-state">Loading versions...</div>';
        modal.classList.remove('hidden');
        
        const data = await loadFirmwareHistory();
        
        // Look for product-specific versions first, fall back to platform-only lookup
        const productKey = `${product}/${platform}`;
        let versions = null;
        
        if (data && data.products && data.products[product] && data.products[product][platform]) {
            versions = data.products[product][platform];
        } else if (data && data.platforms && data.platforms[platform]) {
            // Fallback for legacy structure
            versions = data.platforms[platform];
        }
        
        if (!versions || versions.length === 0) {
            body.innerHTML = '<div class="empty-state">No version history available</div>';
            return;
        }
        
        const rows = versions.map(fw => {
            const uploadDate = new Date(fw.uploaded_at).toLocaleString();
            const latestBadge = fw.is_latest ? '<span class="badge badge-success">Latest</span>' : '';
            const sizeMB = (fw.size / 1024 / 1024).toFixed(2);
            const supportsFullFlash = fw.supports_full_flash || false;
            
            return `
                <tr>
                    <td>
                        ${escapeHtml(fw.version)}
                        ${latestBadge}
                    </td>
                    <td>${sizeMB} MB</td>
                    <td>${uploadDate}</td>
                    <td class="version-actions">
                        <button class="btn-primary btn-small" onclick="showPushModal('${platform}', '${escapeHtml(fw.version)}', '${escapeHtml(product)}')">
                            üì§ OTA Push
                        </button>
                        <button class="btn-secondary btn-small" onclick="showFlashModal('${platform}', '${escapeHtml(fw.version)}', ${supportsFullFlash}, '${escapeHtml(product)}')">
                            ‚ö° USB Flash
                        </button>
                    </td>
                </tr>
            `;
        }).join('');
        
        body.innerHTML = `
            <div class="table-responsive">
                <table class="firmware-table">
                    <thead>
                        <tr>
                            <th>Version</th>
                            <th>Size</th>
                            <th>Uploaded</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
            </div>
        `;
    }
    
    function closeVersionModal() {
        document.getElementById('version-modal').classList.add('hidden');
    }
    
    async function showPushModal(platform, version, product) {
        selectedPushPlatform = platform;
        selectedPushVersion = version;
        
        const modal = document.getElementById('push-modal');
        const title = document.getElementById('push-modal-title');
        const deviceList = document.getElementById('push-device-list');
        
        title.textContent = `Push v${version} to Device`;
        deviceList.innerHTML = '<div class="empty-state">Loading devices...</div>';
        modal.classList.remove('hidden');
        
        try {
            const response = await fetch('/api/devices');
            const data = await response.json();
            
            // Filter devices that match the platform and product
            const matchingDevices = data.devices.filter(d => {
                // Map board types to platforms (simplified mapping)
                const boardToPlatform = {
                    'ESP32-C3': 'esp32c3',
                    'ESP32-S3': 'esp32s3',
                    'ESP32': 'esp32',
                    'ESP-12F': 'esp12f',
                    'ESP-01': 'esp01',
                    'D1 Mini': 'd1mini',
                    'ESP8266': 'esp8266'
                };
                const platformMatch = boardToPlatform[d.board] === platform || d.board.toLowerCase().includes(platform.toLowerCase());
                const productMatch = !product || d.product === product;
                return platformMatch && productMatch;
            });
            
            if (matchingDevices.length === 0) {
                deviceList.innerHTML = `<div class="empty-state">No ${product ? escapeHtml(product) : platform.toUpperCase()} devices found</div>`;
                return;
            }
            
            const deviceItems = matchingDevices.map(d => {
                const statusClass = d.online ? (d.status === 'degraded' ? 'degraded' : 'online') : 'offline';
                const statusIcon = d.online ? (d.status === 'degraded' ? 'üü°' : 'üü¢') : 'üî¥';
                const pinnedBadge = d.pinned_firmware_version ? 
                    `<span class="badge badge-warning">Pinned: ${escapeHtml(d.pinned_firmware_version)}</span>` : '';
                const currentVersion = d.version || 'Unknown';
                
                return `
                    <div class="device-select-item ${statusClass}" onclick="pinDeviceVersion('${d.device_id}', '${selectedPushVersion}')">
                        <div class="device-select-info">
                            <strong>${statusIcon} ${escapeHtml(d.product || 'Unknown Product')} (${escapeHtml(d.device_id)})</strong>
                            <span class="muted-text">v${escapeHtml(currentVersion)}</span>
                            ${pinnedBadge}
                        </div>
                        <button class="btn-primary btn-small">Pin to v${escapeHtml(selectedPushVersion)}</button>
                    </div>
                `;
            }).join('');
            
            deviceList.innerHTML = deviceItems;
            
        } catch (error) {
            console.error('Failed to load devices:', error);
            deviceList.innerHTML = '<div class="empty-state">Failed to load devices</div>';
        }
    }
    
    function closePushModal() {
        document.getElementById('push-modal').classList.add('hidden');
        selectedPushVersion = null;
        selectedPushPlatform = null;
    }
    
    function showFlashModal(platform, version, supportsFullFlash, product) {
        const modal = document.getElementById('flash-modal');
        const title = document.getElementById('flash-modal-title');
        const versionInfo = document.getElementById('flash-version-info');
        const fullOption = document.getElementById('flash-modal-full-option');
        const quickInstaller = document.getElementById('flash-modal-installer-quick');
        const fullInstaller = document.getElementById('flash-modal-installer-full');
        
        // Store flash info for logging
        currentFlashInfo = {
            platform: platform,
            product: product || 'unknown',
            version: version,
            flashMode: 'quick'  // Default, updated when user clicks
        };
        
        // Pause all refresh intervals to reduce memory pressure during flashing
        pauseAllRefresh();
        
        const displayName = product ? `${product} (${platform.toUpperCase()})` : platform.toUpperCase();
        title.textContent = `USB Flash - ${displayName} v${version}`;
        versionInfo.textContent = `Flashing ${displayName} firmware version ${version}`;
        
        const productParam = product ? `&product=${encodeURIComponent(product)}` : '';
        quickInstaller.setAttribute('manifest', `/firmware/manifest/${platform}.json?mode=quick&version=${encodeURIComponent(version)}${productParam}`);
        
        // Track which flash mode is selected
        quickInstaller.onclick = () => { if (currentFlashInfo) currentFlashInfo.flashMode = 'quick'; };
        
        if (supportsFullFlash) {
            fullOption.style.display = 'block';
            fullInstaller.setAttribute('manifest', `/firmware/manifest/${platform}.json?mode=full&version=${encodeURIComponent(version)}${productParam}`);
            fullInstaller.onclick = () => { if (currentFlashInfo) currentFlashInfo.flashMode = 'full'; };
        } else {
            fullOption.style.display = 'none';
        }
        
        modal.classList.remove('hidden');
    }
    
    function closeFlashModal() {
        document.getElementById('flash-modal').classList.add('hidden');
        // Clear flash info
        currentFlashInfo = null;
        currentFlashSession = null;
        // Resume all refresh intervals after flashing completes
        resumeAllRefresh();
    }
    
    async function pinDeviceVersion(deviceId, version) {
        try {
            const response = await fetch(`/api/devices/${deviceId}/pin-version`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ version: version })
            });
            
            const data = await response.json();
            
            if (response.ok) {
                alert(data.message || `Device ${deviceId} pinned to version ${version}`);
                closePushModal();
                closeVersionModal();
                loadDevices(); // Refresh device list
            } else {
                alert(`Failed to pin device: ${data.error}`);
            }
        } catch (error) {
            console.error('Failed to pin device:', error);
            alert('Failed to pin device');
        }
    }
    
    async function unpinDeviceVersion(deviceId) {
        if (!confirm(`Remove version pin from device ${deviceId}? It will follow the latest version again.`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/devices/${deviceId}/pin-version`, {
                method: 'DELETE'
            });
            
            const data = await response.json();
            
            if (response.ok) {
                alert(data.message || `Device ${deviceId} unpinned`);
                loadDevices(); // Refresh device list
            } else {
                alert(`Failed to unpin device: ${data.error}`);
            }
        } catch (error) {
            console.error('Failed to unpin device:', error);
            alert('Failed to unpin device');
        }
    }
    
    // Close modals on outside click
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('modal')) {
            e.target.classList.add('hidden');
        }
    });
    
    // Close modals on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            document.querySelectorAll('.modal').forEach(modal => modal.classList.add('hidden'));
        }
    });

    // Initial load
    checkWebSerialSupport();
    loadOTAStats();
    loadDevices();
    loadFirmware();
    loadEventsFeed();

    // Update live timestamps every second for smooth counting
    timestampInterval = setInterval(updateLiveTimestamps, 1000);
    
    // Refresh OTA stats every 30 seconds
    otaStatsInterval = setInterval(loadOTAStats, 30000);

    // Device refresh interval is managed dynamically by adjustRefreshInterval()
    // based on OTA status (1s during OTA, 10s otherwise)
    deviceRefreshInterval = setInterval(loadDevices, currentRefreshRate);
    
    firmwareInterval = setInterval(loadFirmware, 60000);
    
    // Refresh events feed every 10 seconds
    eventsInterval = setInterval(loadEventsFeed, 10000);
</script>
{% endblock %}
