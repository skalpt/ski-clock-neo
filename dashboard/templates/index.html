{% extends "base.html" %}

{% block title %}Ski Clock Neo - Firmware Dashboard{% endblock %}

{% block extra_head %}
<script type="module" src="https://unpkg.com/esp-web-tools@10/dist/web/install-button.js?module"></script>
{% endblock %}

{% block content %}
<div class="container">
    <div class="header-bar">
        <div class="header-content">
            <h1>‚õ∑Ô∏è Ski Clock Neo</h1>
            <p class="subtitle">Firmware Dashboard & Device Monitoring</p>
        </div>
        <a href="/logout" class="logout-btn">Logout</a>
    </div>

    <div class="card">
        <h2>üì° Live Devices</h2>
        <div id="stats-container"></div>
        <div id="devices-container">
            <div class="empty-state">
                <p>Loading device data...</p>
            </div>
        </div>
    </div>

    <div class="card events-feed-container">
        <div class="events-feed-header">
            <div class="flex-align-center">
                <h2>üìã Events</h2>
            </div>
            <a href="/history?tab=events" class="action-link">Events History ‚Üí</a>
        </div>
        <div id="events-feed-container">
            <div class="empty-state">
                <p>Loading events...</p>
            </div>
        </div>
    </div>

    <div class="card">
        <h2>üì¶ Firmware Versions</h2>
        <div class="table-responsive">
            <table class="firmware-table" id="firmware-table">
                <thead>
                    <tr>
                        <th>Platform</th>
                        <th>Filename</th>
                        <th>Version</th>
                        <th class="flash-column">Flash to Device</th>
                        <th>History</th>
                    </tr>
                </thead>
                <tbody id="firmware-body">
                    <tr>
                        <td colspan="5" class="muted-text text-center">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
    
    <div id="version-modal" class="modal hidden">
        <div class="modal-content modal-lg">
            <div class="modal-header">
                <h3 id="version-modal-title">Version History</h3>
                <button class="modal-close" onclick="closeVersionModal()">&times;</button>
            </div>
            <div class="modal-body" id="version-modal-body">
                <div class="empty-state">Loading versions...</div>
            </div>
        </div>
    </div>
    
    <div id="push-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="push-modal-title">Push Version to Device</h3>
                <button class="modal-close" onclick="closePushModal()">&times;</button>
            </div>
            <div class="modal-body" id="push-modal-body">
                <p>Select a device to push this version to:</p>
                <div id="push-device-list" class="device-select-list">
                    <div class="empty-state">Loading devices...</div>
                </div>
            </div>
        </div>
    </div>

    <div class="card">
        <div class="flex-between mb-15">
            <h2>üìä OTA Update Statistics</h2>
            <a href="/history?tab=ota" class="action-link">OTA Update History ‚Üí</a>
        </div>
        <div id="ota-stats-container">
            <div class="empty-state">
                <p>Loading OTA statistics...</p>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // HTML escape function to prevent XSS attacks
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Check if IP address is IPv4 (for clickable links)
    function isIPv4(ip) {
        // Simple check: IPv4 has dots, IPv6 has colons
        return ip && !ip.includes(':');
    }

    async function loadOTAStats() {
        try {
            const response = await fetch('/api/ota-stats');
            const data = await response.json();
            
            const container = document.getElementById('ota-stats-container');
            container.innerHTML = `
                <div class="ota-stats-grid">
                    <div class="ota-stat-card">
                        <div class="label">Total Updates</div>
                        <div class="value">${data.total_updates}</div>
                    </div>
                    <div class="ota-stat-card success">
                        <div class="label">Successful</div>
                        <div class="value">${data.success_count}</div>
                    </div>
                    <div class="ota-stat-card failed">
                        <div class="label">Failed</div>
                        <div class="value">${data.failed_count}</div>
                    </div>
                    <div class="ota-stat-card in-progress">
                        <div class="label">In Progress</div>
                        <div class="value">${data.in_progress_count}</div>
                    </div>
                    <div class="ota-stat-card">
                        <div class="label">Success Rate</div>
                        <div class="value">${data.success_rate}%</div>
                    </div>
                    <div class="ota-stat-card">
                        <div class="label">Avg Duration</div>
                        <div class="value">${data.avg_duration_seconds}s</div>
                    </div>
                </div>
            `;
        } catch (error) {
            console.error('Failed to load OTA stats:', error);
            const container = document.getElementById('ota-stats-container');
            container.innerHTML = `
                <div class="empty-state">
                    <p>No OTA update data available yet</p>
                </div>
            `;
        }
    }

    // Dynamic refresh interval management
    let deviceRefreshInterval = null;
    let currentRefreshRate = 10000; // Default: 10 seconds
    
    async function loadDevices() {
        try {
            const [devicesResponse, progressResponse] = await Promise.all([
                fetch('/api/devices'),
                fetch('/api/ota-progress')
            ]);
            
            const data = await devicesResponse.json();
            const otaProgress = await progressResponse.json();
            
            // Check if any OTA updates are in progress
            const hasActiveOTA = Object.keys(otaProgress).length > 0;
            
            const container = document.getElementById('devices-container');
            const statsContainer = document.getElementById('stats-container');
            
            if (data.count === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <p>${data.mqtt_enabled ? 'No devices connected yet' : 'MQTT monitoring not configured'}</p>
                        <p class="muted-text small-text-margin">
                            ${data.mqtt_enabled ? 'Devices will appear here when they send heartbeats' : 'Configure MQTT credentials to enable device monitoring'}
                        </p>
                    </div>
                `;
                statsContainer.innerHTML = '';
                return;
            }

            // Calculate degraded count
            const degradedCount = data.devices.filter(d => d.status === 'degraded').length;
            
            // Stats bar
            statsContainer.innerHTML = `
                <div class="stats-bar">
                    <div>Total: <span>${data.count}</span></div>
                    <div>üü¢ Online: <span>${data.online_count - degradedCount}</span></div>
                    ${degradedCount > 0 ? `<div>üü† Degraded: <span>${degradedCount}</span></div>` : ''}
                    <div>üî¥ Offline: <span>${data.offline_count}</span></div>
                </div>
            `;

            const devicesHtml = data.devices.map(device => {
                // Escape all user-supplied data to prevent XSS
                const safeDeviceId = escapeHtml(device.device_id);
                const safeBoard = escapeHtml(device.board);
                const safeVersion = escapeHtml(device.version);
                const safeSsid = escapeHtml(device.ssid);
                const safeIpAddress = escapeHtml(device.ip_address);
                
                // Check if this device has an OTA update in progress
                const ota = otaProgress[device.device_id];
                const otaHtml = ota ? `
                    <div class="ota-progress">
                        <div class="ota-progress-label">
                            üîÑ Updating: ${escapeHtml(ota.old_version || 'Unknown')} ‚Üí ${escapeHtml(ota.new_version)}
                        </div>
                        <div class="ota-progress-bar">
                            <div class="ota-progress-fill" data-progress="${ota.progress}"></div>
                            <div class="ota-progress-text">${ota.progress}%</div>
                        </div>
                    </div>
                ` : '';
                
                // Determine CSS class based on status
                const statusClass = device.status === 'offline' ? 'offline' : device.status === 'degraded' ? 'degraded' : '';
                const statusText = device.status.charAt(0).toUpperCase() + device.status.slice(1);
                
                return `
                <div class="device-card-flip-container" data-device-id="${safeDeviceId}">
                    <div class="device-card-flipper">
                        <div class="device-card-front">
                            <div class="device-card ${statusClass}">
                                <div class="device-header">
                                    <div>
                                        <span class="status ${statusClass}"></span>
                                        ${safeDeviceId}
                                    </div>
                                    <div class="flex-align-center">
                                        <span class="badge">${safeBoard}</span>
                                        <button class="flip-icon-btn" data-device-id="${safeDeviceId}" data-action="flip" title="View display snapshot">
                                            üîÑ
                                        </button>
                                    </div>
                                </div>
                                <div class="device-info">
                                    <div><strong>Status:</strong> ${statusText}${device.status === 'degraded' ? ' (unstable connection)' : ''}</div>
                                    <div><strong>Version:</strong> ${safeVersion}${device.pinned_firmware_version ? ` <span class="badge badge-warning" title="Version pinned - device will not auto-update">üìå Pinned</span>` : ''}</div>
                                    <div><strong>Uptime:</strong> ${formatUptime(device.uptime)}</div>
                                    ${device.ssid ? `<div><strong>WiFi Network:</strong> ${safeSsid}</div>` : ''}
                                    ${device.ip_address ? `<div><strong>IP Address:</strong> ${device.online && isIPv4(device.ip_address) ? `<a href="http://${encodeURIComponent(device.ip_address)}/" target="_blank" rel="noopener noreferrer" class="device-ip-link" title="Open AutoConnect page (only works if you're on the same network)">${safeIpAddress}</a>` : safeIpAddress}</div>` : ''}
                                    <div><strong>WiFi Signal:</strong> ${getSignalStrengthIcon(device.rssi)}${device.rssi} dBm</div>
                                    <div><strong>Free Memory:</strong> ${(device.free_heap / 1024).toFixed(1)} KB</div>
                                    <div><strong>Last Seen:</strong> <span class="live-timestamp" data-timestamp="${escapeHtml(device.last_seen)}">${formatTimestamp(device.last_seen)}</span></div>
                                    <div><strong>First Seen:</strong> ${new Date(device.first_seen).toLocaleString()}</div>
                                </div>
                                ${otaHtml}
                                <div class="device-actions">
                                    <button class="device-btn rollback-btn" data-device-id="${safeDeviceId}" data-action="rollback" ${device.status === 'offline' ? 'disabled title="Device must be online"' : ''}>
                                        ‚èÆÔ∏è Rollback
                                    </button>
                                    <button class="device-btn restart-btn" data-device-id="${safeDeviceId}" data-action="restart" ${device.status === 'offline' ? 'disabled title="Device must be online"' : ''}>
                                        üîÑ Restart
                                    </button>
                                    ${device.pinned_firmware_version ? `
                                    <button class="device-btn unpin-btn" data-device-id="${safeDeviceId}" data-action="unpin" title="Remove version pin - device will follow latest">
                                        üìå Unpin
                                    </button>
                                    ` : ''}
                                    <button class="device-btn delete-btn" data-device-id="${safeDeviceId}" data-action="delete">
                                        üóëÔ∏è Remove
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="device-card-back ${statusClass}" id="display-back-${safeDeviceId}">
                            <div class="device-header">
                                <div class="flex-align-center">
                                    <span class="status ${statusClass}"></span>
                                    ${safeDeviceId}
                                </div>
                                <div class="flex-align-center">
                                    <span class="badge">${safeBoard}</span>
                                    <button class="flip-icon-btn" data-device-id="${safeDeviceId}" data-action="flip" title="Back to device info">
                                        üîÑ
                                    </button>
                                </div>
                            </div>
                            <div class="text-center-margin">
                                <h3 class="snapshot-heading">Display Snapshot</h3>
                            </div>
                            <div id="display-content-${safeDeviceId}">
                                ${device.display_snapshot ? 
                                    `<div id="panel-grid-${safeDeviceId}" class="panel-grid"></div>
                                     <div class="snapshot-info">
                                         <div>Last updated: ${new Date(device.display_snapshot.timestamp).toLocaleString()}</div>
                                     </div>
                                     <div class="device-actions snapshot-actions">
                                         <button class="device-btn snapshot-btn" data-device-id="${safeDeviceId}" data-action="request-snapshot" ${device.status === 'offline' ? 'disabled' : ''}>
                                             üì∏ Request New
                                         </button>
                                         <a href="/history?tab=snapshots&device=${safeDeviceId}" class="device-btn history-btn">
                                             üìú History
                                         </a>
                                     </div>` : 
                                    `<div class="no-snapshot-message">
                                        <p>No display snapshot available</p>
                                        <p class="small-muted-text">Request a snapshot to see the display</p>
                                        <button class="snapshot-btn" data-device-id="${safeDeviceId}" data-action="request-snapshot" ${device.status === 'offline' ? 'disabled' : ''}>
                                            üì∏ Request Snapshot
                                        </button>
                                    </div>`
                                }
                            </div>
                        </div>
                    </div>
                </div>
            `;
            }).join('');

            container.innerHTML = `<div class="devices-grid">${devicesHtml}</div>`;
            
            // Attach event listeners to all device action buttons
            document.querySelectorAll('.device-btn, .flip-btn, .flip-icon-btn, .snapshot-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const deviceId = btn.getAttribute('data-device-id');
                    const action = btn.getAttribute('data-action');
                    
                    if (action === 'delete') {
                        deleteDevice(deviceId);
                    } else if (action === 'rollback') {
                        rollbackDevice(deviceId);
                    } else if (action === 'restart') {
                        restartDevice(deviceId);
                    } else if (action === 'flip') {
                        flipCard(deviceId);
                    } else if (action === 'request-snapshot') {
                        requestSnapshot(deviceId);
                    } else if (action === 'unpin') {
                        unpinDeviceVersion(deviceId);
                    }
                });
            });
            
            // Update all progress bar widths from data attributes
            updateProgressBars();
            
            // Render display snapshots on canvases
            data.devices.forEach(device => {
                if (device.display_snapshot) {
                    renderDisplaySnapshot(device.device_id, device.display_snapshot);
                }
            });
            
            // Restore flip states for cards that were flipped before refresh
            restoreFlipStates();
            
            // Adjust refresh interval based on OTA status
            adjustRefreshInterval(hasActiveOTA);
        } catch (error) {
            console.error('Failed to load devices:', error);
        }
    }
    
    function adjustRefreshInterval(hasActiveOTA) {
        const desiredRate = hasActiveOTA ? 1000 : 10000; // 1s during OTA, 10s otherwise
        
        // Only restart interval if rate needs to change
        if (desiredRate !== currentRefreshRate) {
            currentRefreshRate = desiredRate;
            
            if (deviceRefreshInterval) {
                clearInterval(deviceRefreshInterval);
            }
            
            deviceRefreshInterval = setInterval(loadDevices, currentRefreshRate);
            
            const rateLabel = hasActiveOTA ? '1 second' : '10 seconds';
            console.log(`üîÑ Refresh rate changed to ${rateLabel} (OTA active: ${hasActiveOTA})`);
        }
    }

    async function deleteDevice(deviceId) {
        if (!confirm(`Are you sure you want to remove device ${deviceId}?\n\nThis will permanently delete it from the database.`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/devices/${deviceId}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                alert('Device removed successfully');
                loadDevices();
            } else {
                const error = await response.json();
                alert(`Failed to remove device: ${error.error}`);
            }
        } catch (error) {
            console.error('Failed to delete device:', error);
            alert('Failed to remove device');
        }
    }

    async function rollbackDevice(deviceId) {
        if (!confirm(`Send rollback command to ${deviceId}?\n\nThis will instruct the device to restore its previous firmware version.`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/devices/${deviceId}/rollback`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            
            if (response.ok) {
                alert(data.message || 'Rollback command sent successfully');
            } else {
                alert(`Failed to send rollback command: ${data.error}`);
            }
        } catch (error) {
            console.error('Failed to send rollback command:', error);
            alert('Failed to send rollback command');
        }
    }

    async function restartDevice(deviceId) {
        if (!confirm(`Send restart command to ${deviceId}?\n\nThis will reboot the device.`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/devices/${deviceId}/restart`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            
            if (response.ok) {
                alert(data.message || 'Restart command sent successfully');
            } else {
                alert(`Failed to send restart command: ${data.error}`);
            }
        } catch (error) {
            console.error('Failed to send restart command:', error);
            alert('Failed to send restart command');
        }
    }

    // Track which cards are currently flipped (persists across refreshes)
    const flippedCards = new Set();

    function flipCard(deviceId) {
        const container = document.querySelector(`[data-device-id="${deviceId}"].device-card-flip-container`);
        if (container) {
            container.classList.toggle('flipped');
            
            // Track flip state
            if (container.classList.contains('flipped')) {
                flippedCards.add(deviceId);
            } else {
                flippedCards.delete(deviceId);
            }
        }
    }

    function restoreFlipStates() {
        // Restore flipped state for all cards that were flipped before refresh
        flippedCards.forEach(deviceId => {
            const container = document.querySelector(`[data-device-id="${deviceId}"].device-card-flip-container`);
            if (container && !container.classList.contains('flipped')) {
                const flipper = container.querySelector('.device-card-flipper');
                
                // Temporarily disable transitions to prevent animation on restore
                if (flipper) {
                    flipper.classList.add('no-transition');
                }
                
                container.classList.add('flipped');
                
                // Force reflow to ensure no-transition is applied
                if (flipper) {
                    flipper.offsetHeight; // Trigger reflow
                    
                    // Re-enable transitions after a brief delay
                    setTimeout(() => {
                        flipper.classList.remove('no-transition');
                    }, 10);
                }
            }
        });
    }

    function renderDisplaySnapshot(deviceId, snapshot) {
        // Support all three formats:
        // 1. 'color': Full RGBW per-pixel (4 bytes each)
        // 2. 'mono' + 'monoColor': Bit-packed with uniform color
        // 3. 'pixels': Legacy bit-packed (white)
        const colorData = snapshot ? snapshot.color : null;
        const monoData = snapshot ? (snapshot.mono || snapshot.pixels) : null;
        
        if (!snapshot || (!monoData && !colorData)) return;
        
        const grid = document.getElementById(`panel-grid-${deviceId}`);
        if (!grid) return;
        
        try {
            const width = snapshot.width || 48;
            const height = snapshot.height || 32;
            const rows = snapshot.rows || 2;
            const cols = snapshot.cols || 3;
            
            // Determine rendering mode and prepare data
            const isColorMode = !!colorData;
            let pixelData = null;
            let colorPixelData = null;
            
            if (isColorMode) {
                // Full color mode: 4 bytes per pixel (R, G, B, brightness)
                colorPixelData = atob(colorData);
            } else {
                // Mono mode: bit-packed with optional monoColor
                pixelData = atob(monoData);
            }
            
            // Get mono color from monoColor [R, G, B, brightness] or default to white
            // Apply minimum brightness floor (30%) so dim displays remain visible in preview
            let monoR = 255, monoG = 255, monoB = 255;
            if (snapshot.monoColor && snapshot.monoColor.length >= 3) {
                monoR = snapshot.monoColor[0];
                monoG = snapshot.monoColor[1];
                monoB = snapshot.monoColor[2];
                if (snapshot.monoColor.length >= 4) {
                    const rawBrightness = snapshot.monoColor[3] / 255;
                    const brightness = Math.max(rawBrightness, 0.3); // Minimum 30% for visibility
                    monoR = Math.round(monoR * brightness);
                    monoG = Math.round(monoG * brightness);
                    monoB = Math.round(monoB * brightness);
                }
            }
            
            const panelWidth = width / cols;
            const panelHeight = height / rows;
            
            // Calculate responsive scale factor based on container width
            const container = grid.parentElement;
            const containerWidth = container ? container.clientWidth : 300;
            const gapPixels = (cols - 1) * 1;
            const paddingPixels = 2;
            const availableWidth = containerWidth - gapPixels - paddingPixels - 40;
            
            const maxScaleByWidth = Math.floor(availableWidth / (panelWidth * cols));
            const scale = Math.max(4, Math.min(12, maxScaleByWidth));
            
            grid.innerHTML = '';
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = panelWidth;
                    canvas.height = panelHeight;
                    canvas.style.width = `${panelWidth * scale}px`;
                    canvas.style.height = `${panelHeight * scale}px`;
                    canvas.style.imageRendering = 'pixelated';
                    canvas.style.display = 'block';
                    canvas.style.background = '#000';
                    
                    const ctx = canvas.getContext('2d');
                    const imageData = ctx.createImageData(panelWidth, panelHeight);
                    
                    for (let py = 0; py < panelHeight; py++) {
                        for (let px = 0; px < panelWidth; px++) {
                            const globalX = col * panelWidth + px;
                            const globalY = row * panelHeight + py;
                            const globalPixelIndex = globalY * width + globalX;
                            
                            const i = (py * panelWidth + px) * 4;
                            
                            if (isColorMode) {
                                // Full color mode: read 4 bytes per pixel (R, G, B, brightness)
                                const colorByteIndex = globalPixelIndex * 4;
                                const r = colorPixelData.charCodeAt(colorByteIndex) || 0;
                                const g = colorPixelData.charCodeAt(colorByteIndex + 1) || 0;
                                const b = colorPixelData.charCodeAt(colorByteIndex + 2) || 0;
                                const brightness = (colorPixelData.charCodeAt(colorByteIndex + 3) || 255) / 255;
                                
                                imageData.data[i] = Math.round(r * brightness);
                                imageData.data[i + 1] = Math.round(g * brightness);
                                imageData.data[i + 2] = Math.round(b * brightness);
                                imageData.data[i + 3] = 255;
                            } else {
                                // Mono mode: bit-packed
                                const byteIndex = Math.floor(globalPixelIndex / 8);
                                const bitIndex = globalPixelIndex % 8;
                                const byte = pixelData.charCodeAt(byteIndex) || 0;
                                const isOn = (byte & (1 << bitIndex)) !== 0;
                                
                                if (isOn) {
                                    imageData.data[i] = monoR;
                                    imageData.data[i + 1] = monoG;
                                    imageData.data[i + 2] = monoB;
                                    imageData.data[i + 3] = 255;
                                } else {
                                    imageData.data[i] = 0;
                                    imageData.data[i + 1] = 0;
                                    imageData.data[i + 2] = 0;
                                    imageData.data[i + 3] = 255;
                                }
                            }
                        }
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    grid.appendChild(canvas);
                }
            }
            
        } catch (error) {
            console.error('Failed to render display snapshot:', error);
        }
    }

    async function requestSnapshot(deviceId) {
        try {
            const response = await fetch(`/api/devices/${deviceId}/snapshot`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            
            if (response.ok) {
                alert(data.message || 'Snapshot request sent to device');
            } else {
                alert(`Failed to request snapshot: ${data.error}`);
            }
        } catch (error) {
            console.error('Failed to request snapshot:', error);
            alert('Failed to request snapshot');
        }
    }

    async function loadFirmware() {
        try {
            const response = await fetch('/api/status');
            const data = await response.json();
            const tbody = document.getElementById('firmware-body');
            
            const rows = Object.entries(data.firmwares)
                .filter(([_, fw]) => fw !== null)
                .map(([platform, fw]) => {
                    // Check if user has download permission
                    const canDownload = fw.can_download !== false;
                    const downloadUrl = fw.public_download_url || fw.download_url || '#';
                    const supportsFullFlash = fw.supports_full_flash || false;
                    
                    // Render different content based on permission
                    if (canDownload) {
                        // Build flash button with dropdown for full flash if available
                        let flashButtons;
                        
                        if (supportsFullFlash) {
                            // Mode-switcher button with dropdown for Quick/Full Flash
                            flashButtons = `
                                <div class="split-button-group" data-platform="${platform}">
                                    <esp-web-install-button id="flash-installer-${platform}" manifest="/firmware/manifest/${platform}.json?mode=quick">
                                        <button slot="activate" class="flash-btn flash-btn-main" id="flash-btn-${platform}">
                                            <span class="flash-btn-icon">‚ö°</span>
                                            <span class="flash-btn-text">Quick Flash</span>
                                        </button>
                                    </esp-web-install-button>
                                    <button class="flash-btn flash-btn-dropdown" onclick="toggleFlashDropdown(event, '${platform}')" title="Flash options">‚ñº</button>
                                    <div class="flash-dropdown" id="flash-dropdown-${platform}">
                                        <button class="flash-dropdown-item" onclick="switchFlashMode('${platform}', 'full')" data-mode="full">
                                            <span class="flash-btn-icon">üîß</span> Full Flash (Recovery)
                                        </button>
                                        <button class="flash-dropdown-item is-hidden" onclick="switchFlashMode('${platform}', 'quick')" data-mode="quick">
                                            <span class="flash-btn-icon">‚ö°</span> Quick Flash
                                        </button>
                                    </div>
                                </div>
                            `;
                        } else {
                            // Single Quick Flash button (same width as split buttons)
                            flashButtons = `
                                <div class="split-button-group">
                                    <esp-web-install-button manifest="/firmware/manifest/${platform}.json?mode=quick">
                                        <button slot="activate" class="flash-btn flash-btn-main flash-btn-single">
                                            <span class="flash-btn-icon">‚ö°</span>
                                            <span class="flash-btn-text">Quick Flash</span>
                                        </button>
                                    </esp-web-install-button>
                                </div>
                            `;
                        }
                        
                        return `
                            <tr>
                                <td><strong>${platform.toUpperCase()}</strong></td>
                                <td><a href="${downloadUrl}" class="table-link">${escapeHtml(fw.filename || 'Unknown')}</a></td>
                                <td>${escapeHtml(fw.version || 'Unknown')}</td>
                                <td class="flash-column">
                                    ${flashButtons}
                                </td>
                                <td>
                                    <button class="btn-secondary btn-small" onclick="showVersionHistory('${platform}')">
                                        üìú History
                                    </button>
                                </td>
                            </tr>
                        `;
                    } else {
                        return `
                            <tr class="opacity-50">
                                <td><strong>${platform.toUpperCase()}</strong></td>
                                <td>${escapeHtml(fw.filename || 'Unknown')}</td>
                                <td>${escapeHtml(fw.version || 'Unknown')}</td>
                                <td class="flash-column"><span class="muted-text">No Permission</span></td>
                                <td>
                                    <button class="btn-secondary btn-small" onclick="showVersionHistory('${platform}')">
                                        üìú History
                                    </button>
                                </td>
                            </tr>
                        `;
                    }
                }).join('');

            tbody.innerHTML = rows || '<tr><td colspan="5" class="muted-text text-center">No firmware uploaded yet</td></tr>';
        } catch (error) {
            console.error('Failed to load firmware:', error);
        }
    }

    function updateProgressBars() {
        document.querySelectorAll('[data-progress]').forEach(element => {
            const progress = element.getAttribute('data-progress');
            element.style.width = `${progress}%`;
        });
    }

    function formatUptime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        return `${hours}h ${minutes}m`;
    }

    function getSignalStrengthIcon(rssi) {
        // RSSI to signal strength conversion:
        // Excellent: > -50 dBm (4 bars)
        // Good: -50 to -60 dBm (3 bars)
        // Fair: -60 to -70 dBm (2 bars)
        // Poor: < -70 dBm (1 bar)
        let bars = 1;
        if (rssi > -50) bars = 4;
        else if (rssi > -60) bars = 3;
        else if (rssi > -70) bars = 2;
        
        return `
            <span class="signal-icon">
                <span class="bar ${bars >= 1 ? 'active' : ''}"></span>
                <span class="bar ${bars >= 2 ? 'active' : ''}"></span>
                <span class="bar ${bars >= 3 ? 'active' : ''}"></span>
                <span class="bar ${bars >= 4 ? 'active' : ''}"></span>
            </span>
        `;
    }

    function formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diffSeconds = Math.floor((now - date) / 1000);
        
        if (diffSeconds < 60) return `${diffSeconds}s ago`;
        if (diffSeconds < 3600) return `${Math.floor(diffSeconds / 60)}m ago`;
        return date.toLocaleTimeString();
    }

    function updateLiveTimestamps() {
        // Update all live timestamp elements
        const timestamps = document.querySelectorAll('.live-timestamp');
        timestamps.forEach(elem => {
            const timestamp = elem.getAttribute('data-timestamp');
            if (timestamp) {
                elem.textContent = formatTimestamp(timestamp);
            }
        });
    }

    function toggleFlashDropdown(event, platform) {
        event.stopPropagation();
        const dropdown = document.getElementById(`flash-dropdown-${platform}`);
        const allDropdowns = document.querySelectorAll('.flash-dropdown');
        
        // Close all other dropdowns
        allDropdowns.forEach(d => {
            if (d !== dropdown) {
                d.classList.remove('show');
            }
        });
        
        // Toggle this dropdown
        dropdown.classList.toggle('show');
    }

    function switchFlashMode(platform, newMode) {
        // Get the installer element and button
        const installer = document.getElementById(`flash-installer-${platform}`);
        const button = document.getElementById(`flash-btn-${platform}`);
        const dropdown = document.getElementById(`flash-dropdown-${platform}`);
        const group = button.closest('.split-button-group');
        const dropdownBtn = group.querySelector('.flash-btn-dropdown');
        
        // Update manifest URL
        installer.setAttribute('manifest', `/firmware/manifest/${platform}.json?mode=${newMode}`);
        
        // Update button text and icon based on mode
        const iconSpan = button.querySelector('.flash-btn-icon');
        const textSpan = button.querySelector('.flash-btn-text');
        
        if (newMode === 'full') {
            iconSpan.textContent = 'üîß';
            textSpan.textContent = 'Full Flash';
            button.classList.add('full-flash-mode');
            dropdownBtn.classList.add('full-flash-mode');
        } else {
            iconSpan.textContent = '‚ö°';
            textSpan.textContent = 'Quick Flash';
            button.classList.remove('full-flash-mode');
            dropdownBtn.classList.remove('full-flash-mode');
        }
        
        // Toggle dropdown items visibility (show opposite mode)
        const dropdownItems = dropdown.querySelectorAll('.flash-dropdown-item');
        dropdownItems.forEach(item => {
            const itemMode = item.getAttribute('data-mode');
            item.style.display = itemMode === newMode ? 'none' : 'block';
        });
        
        // Close the dropdown
        dropdown.classList.remove('show');
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (event) => {
        if (!event.target.closest('.split-button-group')) {
            document.querySelectorAll('.flash-dropdown').forEach(d => {
                d.classList.remove('show');
            });
        }
    });

    // Handle tab visibility changes to recalculate after backgrounding
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
            // Tab is now visible - recalculate all timestamps immediately
            updateLiveTimestamps();
        }
    });

    // Check for Web Serial API support and hide flash column if not available
    function checkWebSerialSupport() {
        if (!('serial' in navigator)) {
            // Add persistent class to body that hides flash column via CSS
            document.body.classList.add('no-web-serial');
            console.log('Web Serial API not supported - Flash to Device column hidden');
        }
    }

    async function loadEventsFeed() {
        try {
            const response = await fetch('/api/events?limit=10');
            const data = await response.json();
            
            const container = document.getElementById('events-feed-container');
            
            if (!data.events || data.events.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <p>No events yet</p>
                    </div>
                `;
                return;
            }
            
            const tableHtml = `
                <div class="table-responsive">
                    <table class="events-feed-table">
                        <thead>
                            <tr>
                                <th>Time</th>
                                <th>Device</th>
                                <th>Event</th>
                                <th>Details</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.events.map(event => {
                                const eventIcon = getEventIcon(event.event_type);
                                const eventDetails = formatEventData(event.event_type, event.event_data);
                                
                                return `
                                    <tr>
                                        <td>${new Date(event.timestamp).toLocaleTimeString()}</td>
                                        <td>${escapeHtml(event.device_id)}</td>
                                        <td><span class="event-badge ${event.event_type}">${eventIcon} ${formatEventType(event.event_type)}</span></td>
                                        <td>${eventDetails}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = tableHtml;
            
        } catch (error) {
            console.error('Failed to load events feed:', error);
        }
    }

    function getEventIcon(eventType) {
        const icons = {
            'heartbeat': 'üíì',
            'boot': 'üîå',
            'wifi_connect': 'üì∂',
            'wifi_disconnect': 'üìµ',
            'mqtt_connect': 'üîó',
            'mqtt_disconnect': 'üîì',
            'temperature_read': 'üå°Ô∏è',
            'temperature_error': '‚ö†Ô∏è',
            'low_heap_warning': 'üß†',
            'wifi_rssi_low': 'üìâ',
            'temp_sensor_not_found': 'üîç',
            'temp_read_invalid': '‚ùå',
            'temp_read_crc_error': 'üî¢',
            'rtc_initialized': 'üïê',
            'rtc_not_found': 'üîç',
            'rtc_lost_power': 'üîã',
            'rtc_time_invalid': '‚è∞',
            'rtc_synced_from_ntp': 'üîÑ',
            'rtc_sync_failed': '‚ùå',
            'rtc_drift_corrected': '‚úÖ',
            'ntp_sync_success': 'üåê',
            'ntp_sync_failed': 'üåê',
            'button_press': 'üëÜ',
            'button_release': 'üëÜ',
            'display_mode_change': 'üñ•Ô∏è'
        };
        return icons[eventType] || 'üìå';
    }

    function formatEventType(eventType) {
        const labels = {
            'heartbeat': 'Heartbeat',
            'boot': 'Boot',
            'wifi_connect': 'WiFi Connect',
            'wifi_disconnect': 'WiFi Disconnect',
            'mqtt_connect': 'MQTT Connect',
            'mqtt_disconnect': 'MQTT Disconnect',
            'temperature_read': 'Temperature',
            'temperature_error': 'Temperature Error',
            'low_heap_warning': 'Low Heap Warning',
            'wifi_rssi_low': 'Weak WiFi Signal',
            'temp_sensor_not_found': 'Sensor Not Found',
            'temp_read_invalid': 'Invalid Reading',
            'temp_read_crc_error': 'CRC Error',
            'rtc_initialized': 'RTC Ready',
            'rtc_not_found': 'RTC Not Found',
            'rtc_lost_power': 'RTC Battery Low',
            'rtc_time_invalid': 'RTC Time Invalid',
            'rtc_synced_from_ntp': 'RTC Synced',
            'rtc_sync_failed': 'RTC Sync Failed',
            'rtc_drift_corrected': 'RTC Drift Corrected',
            'ntp_sync_success': 'NTP Sync OK',
            'ntp_sync_failed': 'NTP Sync Failed',
            'button_press': 'Button Press',
            'button_release': 'Button Release',
            'display_mode_change': 'Display Mode'
        };
        return labels[eventType] || eventType;
    }

    function formatEventData(eventType, eventData) {
        if (!eventData) return '-';
        
        try {
            const data = typeof eventData === 'string' ? JSON.parse(eventData) : eventData;
            
            switch (eventType) {
                case 'heartbeat':
                    const parts = [];
                    if (data.rssi) parts.push(`${data.rssi} dBm`);
                    if (data.uptime) parts.push(`up: ${formatUptime(data.uptime)}`);
                    return parts.join(', ') || '-';
                case 'boot':
                    return data.reason ? escapeHtml(data.reason) : '-';
                case 'wifi_connect':
                    const wifiParts = [];
                    if (data.ssid) wifiParts.push(escapeHtml(data.ssid));
                    if (data.rssi) wifiParts.push(`${data.rssi} dBm`);
                    return wifiParts.join(', ') || '-';
                case 'temperature_read':
                    return data.celsius !== undefined ? `${data.celsius.toFixed(1)}¬∞C` : '-';
                default:
                    return '-';
            }
        } catch (e) {
            return '-';
        }
    }

    // Version history and push functionality
    let firmwareHistoryCache = null;
    let selectedPushVersion = null;
    let selectedPushPlatform = null;
    
    async function loadFirmwareHistory() {
        if (firmwareHistoryCache) return firmwareHistoryCache;
        
        try {
            const response = await fetch('/api/firmware-history');
            const data = await response.json();
            firmwareHistoryCache = data;
            return data;
        } catch (error) {
            console.error('Failed to load firmware history:', error);
            return null;
        }
    }
    
    async function showVersionHistory(platform) {
        const modal = document.getElementById('version-modal');
        const title = document.getElementById('version-modal-title');
        const body = document.getElementById('version-modal-body');
        
        title.textContent = `Version History - ${platform.toUpperCase()}`;
        body.innerHTML = '<div class="empty-state">Loading versions...</div>';
        modal.classList.remove('hidden');
        
        const data = await loadFirmwareHistory();
        
        if (!data || !data.platforms || !data.platforms[platform]) {
            body.innerHTML = '<div class="empty-state">No version history available</div>';
            return;
        }
        
        const versions = data.platforms[platform];
        
        const rows = versions.map(fw => {
            const uploadDate = new Date(fw.uploaded_at).toLocaleString();
            const latestBadge = fw.is_latest ? '<span class="badge badge-success">Latest</span>' : '';
            const sizeMB = (fw.size / 1024 / 1024).toFixed(2);
            
            return `
                <tr>
                    <td>
                        ${escapeHtml(fw.version)}
                        ${latestBadge}
                    </td>
                    <td>${sizeMB} MB</td>
                    <td>${uploadDate}</td>
                    <td>
                        <button class="btn-primary btn-small" onclick="showPushModal('${platform}', '${escapeHtml(fw.version)}')">
                            üì§ Push to Device
                        </button>
                    </td>
                </tr>
            `;
        }).join('');
        
        body.innerHTML = `
            <div class="table-responsive">
                <table class="firmware-table">
                    <thead>
                        <tr>
                            <th>Version</th>
                            <th>Size</th>
                            <th>Uploaded</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
            </div>
        `;
    }
    
    function closeVersionModal() {
        document.getElementById('version-modal').classList.add('hidden');
    }
    
    async function showPushModal(platform, version) {
        selectedPushPlatform = platform;
        selectedPushVersion = version;
        
        const modal = document.getElementById('push-modal');
        const title = document.getElementById('push-modal-title');
        const deviceList = document.getElementById('push-device-list');
        
        title.textContent = `Push v${version} to Device`;
        deviceList.innerHTML = '<div class="empty-state">Loading devices...</div>';
        modal.classList.remove('hidden');
        
        try {
            const response = await fetch('/api/devices');
            const data = await response.json();
            
            // Filter devices that match the platform
            const matchingDevices = data.devices.filter(d => {
                // Map board types to platforms (simplified mapping)
                const boardToPlatform = {
                    'ESP32-C3': 'esp32c3',
                    'ESP32-S3': 'esp32s3',
                    'ESP32': 'esp32',
                    'ESP-12F': 'esp12f',
                    'ESP-01': 'esp01',
                    'D1 Mini': 'd1mini',
                    'ESP8266': 'esp8266'
                };
                return boardToPlatform[d.board] === platform || d.board.toLowerCase().includes(platform.toLowerCase());
            });
            
            if (matchingDevices.length === 0) {
                deviceList.innerHTML = `<div class="empty-state">No ${platform.toUpperCase()} devices found</div>`;
                return;
            }
            
            const deviceItems = matchingDevices.map(d => {
                const statusClass = d.online ? (d.status === 'degraded' ? 'degraded' : 'online') : 'offline';
                const statusIcon = d.online ? (d.status === 'degraded' ? 'üü°' : 'üü¢') : 'üî¥';
                const pinnedBadge = d.pinned_firmware_version ? 
                    `<span class="badge badge-warning">Pinned: ${escapeHtml(d.pinned_firmware_version)}</span>` : '';
                const currentVersion = d.version || 'Unknown';
                
                return `
                    <div class="device-select-item ${statusClass}" onclick="pinDeviceVersion('${d.device_id}', '${selectedPushVersion}')">
                        <div class="device-select-info">
                            <strong>${statusIcon} ${escapeHtml(d.device_id)}</strong>
                            <span class="muted-text">v${escapeHtml(currentVersion)}</span>
                            ${pinnedBadge}
                        </div>
                        <button class="btn-primary btn-small">Pin to v${escapeHtml(selectedPushVersion)}</button>
                    </div>
                `;
            }).join('');
            
            deviceList.innerHTML = deviceItems;
            
        } catch (error) {
            console.error('Failed to load devices:', error);
            deviceList.innerHTML = '<div class="empty-state">Failed to load devices</div>';
        }
    }
    
    function closePushModal() {
        document.getElementById('push-modal').classList.add('hidden');
        selectedPushVersion = null;
        selectedPushPlatform = null;
    }
    
    async function pinDeviceVersion(deviceId, version) {
        try {
            const response = await fetch(`/api/devices/${deviceId}/pin-version`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ version: version })
            });
            
            const data = await response.json();
            
            if (response.ok) {
                alert(data.message || `Device ${deviceId} pinned to version ${version}`);
                closePushModal();
                closeVersionModal();
                loadDevices(); // Refresh device list
            } else {
                alert(`Failed to pin device: ${data.error}`);
            }
        } catch (error) {
            console.error('Failed to pin device:', error);
            alert('Failed to pin device');
        }
    }
    
    async function unpinDeviceVersion(deviceId) {
        if (!confirm(`Remove version pin from device ${deviceId}? It will follow the latest version again.`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/devices/${deviceId}/pin-version`, {
                method: 'DELETE'
            });
            
            const data = await response.json();
            
            if (response.ok) {
                alert(data.message || `Device ${deviceId} unpinned`);
                loadDevices(); // Refresh device list
            } else {
                alert(`Failed to unpin device: ${data.error}`);
            }
        } catch (error) {
            console.error('Failed to unpin device:', error);
            alert('Failed to unpin device');
        }
    }
    
    // Close modals on outside click
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('modal')) {
            e.target.classList.add('hidden');
        }
    });
    
    // Close modals on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            document.querySelectorAll('.modal').forEach(modal => modal.classList.add('hidden'));
        }
    });

    // Initial load
    checkWebSerialSupport();
    loadOTAStats();
    loadDevices();
    loadFirmware();
    loadEventsFeed();

    // Update live timestamps every second for smooth counting
    setInterval(updateLiveTimestamps, 1000);
    
    // Refresh OTA stats every 30 seconds
    setInterval(loadOTAStats, 30000);

    // Device refresh interval is managed dynamically by adjustRefreshInterval()
    // based on OTA status (1s during OTA, 10s otherwise)
    deviceRefreshInterval = setInterval(loadDevices, currentRefreshRate);
    
    setInterval(loadFirmware, 60000);
    
    // Refresh events feed every 10 seconds
    setInterval(loadEventsFeed, 10000);
</script>
{% endblock %}
