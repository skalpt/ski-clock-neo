// Direct port manipulation for fast GPIO operations in interrupt context
#if defined(ESP8266)
  #include <esp8266_peri.h>
  #define FAST_PIN_HIGH(pin) GPOS = (1 << (pin))
  #define FAST_PIN_LOW(pin)  GPOC = (1 << (pin))
#elif defined(CONFIG_IDF_TARGET_ESP32C3)
  // ESP32-C3 has only 22 GPIOs (bank 0 only, no out1 registers)
  #include <soc/gpio_reg.h>
  #define FAST_PIN_HIGH(pin) GPIO.out_w1ts.val = (1UL << (pin))
  #define FAST_PIN_LOW(pin)  GPIO.out_w1tc.val = (1UL << (pin))
#elif defined(CONFIG_IDF_TARGET_ESP32S3)
  // ESP32-S3 has 48 GPIOs (needs dual GPIO banks for pins 0-31 and 32-48)
  // Bank 0: direct uint32_t (no .val), Bank 1: struct with .val
  #include <soc/gpio_reg.h>
  #define FAST_PIN_HIGH(pin) do { \
    if ((pin) < 32) { \
      GPIO.out_w1ts = (1UL << (pin)); \
    } else { \
      GPIO.out1_w1ts.val = (1UL << ((pin) - 32)); \
    } \
  } while(0)
  
  #define FAST_PIN_LOW(pin) do { \
    if ((pin) < 32) { \
      GPIO.out_w1tc = (1UL << (pin)); \
    } else { \
      GPIO.out1_w1tc.val = (1UL << ((pin) - 32)); \
    } \
  } while(0)
#elif defined(ESP32)
  // ESP32 original - direct register access
  #include <soc/gpio_reg.h>
  #define FAST_PIN_HIGH(pin) GPIO.out_w1ts = (1 << (pin))
  #define FAST_PIN_LOW(pin)  GPIO.out_w1tc = (1 << (pin))
#else
  // Fallback to digitalWrite for other platforms
  #define FAST_PIN_HIGH(pin) digitalWrite(pin, HIGH)
  #define FAST_PIN_LOW(pin)  digitalWrite(pin, LOW)
#endif

// Helper functions to handle LED on/off with inverted logic
inline void IRAM_ATTR ledOn() {
  if (LED_GPIO_ON == LOW) {
    FAST_PIN_LOW(LED_PIN);
  } else {
    FAST_PIN_HIGH(LED_PIN);
  }
}

inline void IRAM_ATTR ledOff() {
  if (LED_GPIO_ON == LOW) {
    FAST_PIN_HIGH(LED_PIN);
  } else {
    FAST_PIN_LOW(LED_PIN);
  }
}

// Hardware timer for LED updates
#if defined(ESP32)
  hw_timer_t *ledTimer = NULL;
  portMUX_TYPE ledTimerMux = portMUX_INITIALIZER_UNLOCKED;
#elif defined(ESP8266)
  // ESP8266 uses Timer1 (hardware timer)
  extern "C" {
    #include "user_interface.h"
  }
#endif