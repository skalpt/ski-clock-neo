With the firmware reorganisation, can we make it so that there is a single include for the lib/ files, meaning that when we start a new project we only need to add a single include to import in place of what we have currently:

#include "src/core/debug.h"
#include "src/core/timer_helpers.h"
#include "src/core/event_log.h"
#include "src/core/led_indicator.h"
#include "src/display/display_core.h"
#include "src/connectivity/wifi_config.h"
#include "src/connectivity/mqtt_client.h"

We can do the same for setup, so just have a single line initNorrtekIoT() in place of:

  // Initialize event logging and log boot event
  initEventLog();
  logBootEvent();
  // Initialize onboard LED indicator
  initLedIndicator();
  // Initialize display (includes time, temperature, and button initialization)
  initDisplay();
  // Initialise WiFi
  initWiFi();
  
  // Initialize MQTT system
  initMQTT();

And same in the loop, just processNorrtekIoT() in place of:

  // Handle WiFi tasks (config portal or reconnection)
updateWiFi();
// Handle MQTT updates (subscriptions and version requests)
updateMQTT();
// Update timers (ESP8266 only - loop-driven, non-ISR, WiFi-safe)
// ESP32 uses FreeRTOS tasks, so no updates needed in loop
#if defined(ESP8266)
  updateTimers();  // All timer_task managed timers (display, toggle, time check, temperature, button)
#endif

Then we just need to think of a clean way to drop in the custom config, display controller and data libraries to new projects so that we don't have reference issues all over the place.

2 hours ago

Show less

Planned unified header integration (14 seconds)
"Norrtek IoT" - nice! I like the clean API approach too. Here's how I'm thinking about structuring it:

Unified Library Design
Single include:

#include <norrtek_iot.h>  // Brings in everything from lib/

Simplified setup/loop:

void setup() {
  initNorrtekIoT();      // All core initialization
  initProductFeatures(); // Product-specific (display_controller, sensors)
}
void loop() {
  processNorrtekIoT();   // Core updates (WiFi, MQTT, timers)
}

For product-specific integration, I'm thinking a callback registration pattern:

// In norrtek_iot.h - products register their display update callback
void setDisplayUpdateCallback(void (*callback)());
// In your product's display_controller.cpp
void initProductFeatures() {
  initTimeData();
  initTemperatureData();
  initDisplayController();
  setDisplayUpdateCallback(updateDisplay);  // Called by framework
}

The shared lib would provide hooks where products plug in their custom behavior, keeping the core framework clean and the product code isolated.

Folder structure:

firmware/
├── lib/norrtek-iot/           # Shared library (can be git submodule)
│   ├── norrtek_iot.h          # Single unified include
│   ├── norrtek_iot.cpp        # init/process implementations
│   ├── core/
│   ├── connectivity/
│   └── display/
│
└── products/ski-clock-neo/    # Product-specific
    ├── ski-clock-neo.ino
    ├── config.h
    ├── display_controller.*
    └── data/

Does this callback approach work for you, or would you prefer a different pattern for hooking in the product-specific code?

26 seconds of work
Yes that looks clean. We also need to think about other libraries that are tied together - for example event_log.h sits in a lot of the data libraries, and of course debug.h is everywhere...

2 hours ago

Show less

Decided on unified header structure (13 seconds)
Right, the dependency chain matters. Here's how I see the hierarchy:

Include order in norrtek_iot.h:

// Level 0 - No dependencies
#include "core/debug.h"
#include "core/device_info.h"
// Level 1 - Platform only
#include "core/timer_helpers.h"
// Level 2 - Depends on core
#include "core/event_log.h"      // uses timer_helpers, device_info
#include "core/led_indicator.h"  // uses timer_helpers
// Level 3 - Display
#include "display/font_5x7.h"
#include "display/display_core.h"  // uses timer_helpers
// Level 4 - Connectivity
#include "connectivity/wifi_config.h"  // uses event_log
#include "connectivity/mqtt_client.h"  // uses event_log, device_info
#include "connectivity/ota_update.h"   // uses mqtt_client

For product code, since they include norrtek_iot.h, everything is available:

// data_temperature.cpp (product-specific)
#include <norrtek_iot.h>  // Gets debug.h, event_log.h, etc.
void readTemperature() {
  DEBUG_PRINT("Reading temp");
  logEvent(TEMPERATURE_READ, tempValue);
}

The unified header acts as the "umbrella" - product code gets all utilities through one include, and the header handles the correct dependency order internally.

Want me to create the task list for implementing this? The phases would be:

Dashboard rebrand - Rename to "Norrtek IoT" throughout
Database update - Add product column, backfill existing data
Firmware restructure - Create lib/norrtek-iot/ with unified header
Move ski-clock-neo - Refactor as first product under new structure
Update replit.md - Document new architecture