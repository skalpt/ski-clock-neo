# Ski Clock Neo - Project Documentation

## Overview
Ski Clock Neo integrates Arduino firmware for ESP32/ESP8266 microcontrollers with NeoPixel LED matrix displays and a custom, secure firmware update server. The system provides dynamic content display on 16x16 NeoPixel matrices and enables automatic, secure over-the-air (OTA) updates via a Python Flask dashboard. This project aims for robust deployment, simplified management of embedded devices, and easy migration to self-hosted infrastructure, focusing on high reliability and seamless updates.

## User Preferences
- Target platform: ESP32/ESP8266 (not standard Arduino)
- Multi-panel support is intentional (not a bug)
- Private repository (no public releases)
- Configurable server URL for future migration

## System Architecture
The project comprises two main components:

**1. Firmware (Embedded C++ for ESP32/ESP8266):**
*   **Features**: Drives 16x16 NeoPixel matrices with a custom 5x7 pixel font, supports multi-panel setups, includes a freeze-proof LED status indicator using hardware interrupt timers, and manages WiFi via `AutoConnect` (multi-network, captive portal, background reconnection). Secure non-blocking OTA updates are handled via a custom server with API key authentication and HTTPS. NeoPixel updates utilize FreeRTOS tasks on ESP32 for smooth rendering.
*   **Modular Display Architecture**: Hardware configuration centralized in `display_config.h` (single source of truth for DISPLAY_ROWS, panel dimensions, buffer size). Generic `display.{h,cpp}` library manages display buffer (bit-packed for memory efficiency) and text content storage, fully hardware-agnostic. The `neopixel_render.h` renderer uses placement-new for dynamic row initialization, loops through rows for rendering, and commits unified frames to display buffer. NeoPixel transformations (90° rotation, serpentine wiring, panel layout) are handled via `xyToIndex()` forward mapping and `indexToXY()` inverse mapping to ensure MQTT snapshots serialize clean logical bitmaps. This architecture enables seamless migration to HUB75 panels by creating `hub75_render.h` that also uses `display_config.h`.
*   **Production-Ready Event-Driven Rendering**: Atomic, race-free architecture using critical sections (portENTER_CRITICAL on ESP32, noInterrupts on ESP8266) for all shared state access. setText() atomically performs strcmp/strncpy/sequence increment/flag updates. snapshotAllText() atomically copies all rows for rendering. updateNeoPixels() renders from immutable local snapshots. Sequence counter detects concurrent updates during render. Main loop drain processes all queued updates until stable. Zero race conditions, zero torn reads, zero update loss, zero visual glitches—validated for ESP32 dual-core + MQTT/timer/OTA concurrency.
*   **MQTT Integration**: Publishes device heartbeats (ID, board type, firmware version, uptime, WiFi RSSI, free heap, SSID, IP) every 60 seconds to HiveMQ Cloud. Dashboard automatically checks version on every heartbeat and sends update notification via `skiclock/version/response/{device_id}` if newer firmware is available. No separate version request topic needed - heartbeats handle all version checking. Supports TLS encryption without certificate validation. MQTT buffer increased to 2048 bytes to support display snapshots. JSON parsing handles both standard (with spaces) and compact (without spaces) formats for maximum compatibility.
*   **Display Snapshot System**: Publishes hourly snapshots of display state to `skiclock/display/snapshot/{device_id}` with base64-encoded bit-packed pixel data, panel dimensions (rows/cols), resolution (width/height), and row text JSON array (all display row strings with proper JSON escaping). Supports on-demand snapshots via `snapshot` MQTT command for real-time troubleshooting. The snapshot buffer contains a clean logical bitmap created by reverse-transforming NeoPixel strip indices using `indexToXY()` function (localX=tX, localY=tY), which inverts panel layout, serpentine wiring, and 90° rotation transformations to ensure dashboard visualization matches physical display.
*   **MQTT Command Handling**: Subscribes to device-specific topics for remote management, supporting `rollback` (via dual OTA partition switching on ESP32, re-download on ESP8266), `restart`, and `snapshot` commands.
*   **OTA Progress Reporting**: Publishes real-time OTA status (start, progress, complete) to MQTT topics, allowing granular tracking and dashboard updates.
*   **Display Content System**: Shows alternating time (hh.mm) and date (dd-mm) every 4 seconds on row 0, synced via NTP for Sweden timezone (CET/CEST). Temperature (DS18B20 sensor) displayed on row 1 with non-blocking reads, correct negative rounding via lroundf(), and immediate initial conversion. All data libraries (data_time, data_temperature) use event-driven updates via setText(). Button library provides debounced GPIO interrupt handling for future timer feature.

**2. Dashboard Server (Python Flask application):**
*   **Features**: Provides API-based firmware distribution for multiple platforms (ESP32, ESP32-C3, ESP32-S3, ESP-12F, ESP-01, Wemos D1 Mini), supports firmware upload with API key authentication, platform aliasing, and SHA256 checksums. Integrates with PostgreSQL for persistent device tracking and offers an interactive web dashboard.
*   **MQTT Integration**: Background subscriber connects to HiveMQ Cloud, processes heartbeats, persists device data to PostgreSQL, and exposes live device data via REST API. **Automatic version checking**: On every heartbeat (every 60s), dashboard compares device version with latest available firmware using authoritative BOARD_TYPE_TO_PLATFORM mapping and automatically publishes update notification to `skiclock/version/response/{device_id}` if newer version exists. All 6 board types (ESP32, ESP32-C3, ESP32-S3, ESP-12F, ESP-01, Wemos D1 Mini) are correctly mapped to their firmware platform identifiers. Subscribes to `skiclock/display/snapshot/#` for display state monitoring. Uses cache-aware `get_firmware_version()` function to avoid stale version data from Python import caching.
*   **Display Snapshot Visualization & Debugging**: Stores complete display snapshots in PostgreSQL (DisplaySnapshot table) with both bitmap data (base64-encoded bit-packed pixels with dimensions) and row text (JSON array of strings). Provides `/api/devices/<id>/snapshots` endpoint for paginated snapshot history and `/snapshot-debug` UI page with side-by-side view of intended text vs rendered bitmap for debugging display transformations. Enables requesting on-demand snapshots via MQTT and visualizing device display state for remote troubleshooting.
*   **Degraded Status Detection**: Monitors device heartbeat timestamps to identify "online," "degraded" (2+ missed checkins), and "offline" statuses.
*   **OTA Update Logging & Monitoring**: Tracks all OTA attempts in PostgreSQL, logging progress and status via MQTT. The dashboard displays real-time statistics, provides an OTA history page with filtering, and shows live progress bars.
*   **MQTT Command System**: Enables sending remote `rollback`, `restart`, and `snapshot` commands to devices via MQTT, with API endpoints and dashboard buttons for control.
*   **Device Management**: Stores device registry in PostgreSQL with display snapshot storage, showing status and allowing deletion.
*   **Authentication & Authorization**: Uses session-based authentication for dashboard routes and API key authentication for device API routes. Features Role-Based Access Control (RBAC) with platform-level permissions and user-scoped firmware downloads via signed URL tokens for security.
*   **Browser-Based Firmware Flashing**: Integrates ESP Web Tools for direct USB flashing from the browser (Chrome/Edge), supporting quick and full flash modes (bootloader recovery) using manifest files.
*   **Production Sync**: Development environments automatically sync firmware metadata from production every 5 minutes.
*   **Deployment**: Relies on VM deployment for consistent state and GitHub Actions for CI/CD, automating firmware builds and uploads.
*   **System Design**: Emphasizes automated versioning, secure communication, and graceful fallback for storage.

## External Dependencies
*   **Firmware Libraries**: Adafruit_NeoPixel, AutoConnect, PubSubClient (with TLS support), ESP32 Arduino Core 2.0.14, ESP8266 WiFi libraries.
*   **Dashboard Dependencies**: Flask, paho-mqtt, PostgreSQL, Replit Object Storage (optional, with local filesystem fallback).
*   **Cloud Services**: HiveMQ Cloud Serverless (MQTT broker), GitHub Actions (CI/CD).